use crate::authorship::authorship_log::LineRange;
use crate::authorship::ignore::{build_ignore_matcher, should_ignore_file_with_matcher};
use crate::authorship::transcript::Message;
use crate::error::GitAiError;
use crate::git::refs::get_authorship;
use crate::git::repository::Repository;
use crate::utils::debug_log;
use serde::{Deserialize, Serialize};
use std::collections::{BTreeMap, HashMap};

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct ToolModelHeadlineStats {
    #[serde(default)]
    pub ai_additions: u32, // Number of lines committed with AI attribution (full and/or mixed)
    #[serde(default)]
    pub mixed_additions: u32, // Number of AI-generated lines that were edited by humans before being committed
    #[serde(default)]
    pub ai_accepted: u32, // Number of AI-generated lines that were accepted by the user without any human edits
    #[serde(default)]
    pub total_ai_additions: u32, // Number of lines that were generated by AI while working on this commit
    #[serde(default)]
    pub total_ai_deletions: u32, // Number of lines that were deleted by AI while working on this commit
    #[serde(default)]
    pub time_waiting_for_ai: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct CommitStats {
    #[serde(default)]
    pub human_additions: u32, // Number of lines committed with human attribution (full and/or mixed)
    #[serde(default)]
    pub mixed_additions: u32, // Number of AI-generated lines that were edited by humans before being committed
    #[serde(default)]
    pub ai_additions: u32, // Number of lines committed with AI attribution (full and/or mixed)
    #[serde(default)]
    pub ai_accepted: u32, // Number of AI-generated lines that were accepted by the user without any human edits
    #[serde(default)]
    pub total_ai_additions: u32, // Number of lines that were generated by AI while working on this commit
    #[serde(default)]
    pub total_ai_deletions: u32, // Number of lines that were deleted by AI while working on this commit
    #[serde(default)]
    pub time_waiting_for_ai: u64, // seconds
    #[serde(default)]
    pub git_diff_deleted_lines: u32,
    #[serde(default)]
    pub git_diff_added_lines: u32,
    #[serde(default)]
    pub tool_model_breakdown: BTreeMap<String, ToolModelHeadlineStats>,
}

pub fn stats_command(
    repo: &Repository,
    commit_sha: Option<&str>,
    json: bool,
    ignore_patterns: &[String],
) -> Result<(), GitAiError> {
    let (target, refname) = if let Some(sha) = commit_sha {
        // Validate that the commit exists using revparse_single
        match repo.revparse_single(sha) {
            Ok(commit_obj) => {
                // For a specific commit, we don't have a refname, so use the commit SHA
                let full_sha = commit_obj.id();
                (full_sha, sha.to_string())
            }
            Err(GitAiError::GitCliError { .. }) => {
                return Err(GitAiError::Generic(format!("No commit found: {}", sha)));
            }
            Err(e) => return Err(e),
        }
    } else {
        // Default behavior: use current HEAD
        let head = repo.head()?;
        let target = head.target()?;
        let name = head.name().unwrap_or("HEAD").to_string();
        (target, name)
    };

    debug_log(&format!(
        "Stats command found commit: {} refname: {}",
        target, refname
    ));

    let stats = stats_for_commit_stats(repo, &target, ignore_patterns)?;

    if json {
        let json_str = serde_json::to_string(&stats)?;
        println!("{}", json_str);
    } else {
        write_stats_to_terminal(&stats, true);
    }

    Ok(())
}

pub fn write_stats_to_terminal(stats: &CommitStats, print: bool) -> String {
    let mut output = String::new();

    // Set maximum bar width to 40 characters
    let bar_width: usize = 40;

    // Handle deletion-only commits (no additions)
    if stats.git_diff_added_lines == 0 && stats.git_diff_deleted_lines > 0 {
        // Show gray bar for deletion-only commit
        let mut progress_bar = String::new();
        progress_bar.push_str("you  ");
        progress_bar.push_str("\x1b[90m"); // Gray color
        progress_bar.push_str(&" ".repeat(bar_width)); // Gray bar
        progress_bar.push_str("\x1b[0m"); // Reset color
        progress_bar.push_str(" ai");

        output.push_str(&progress_bar);
        output.push('\n');
        if print {
            println!("{}", progress_bar);
        }

        // Show "(no additions)" message below the bar
        let no_additions_msg = format!("     \x1b[90m{:^40}\x1b[0m", "(no additions)");
        output.push_str(&no_additions_msg);
        output.push('\n');
        if print {
            println!("{}", no_additions_msg);
        }
        // No percentage line or AI stats for deletion-only commits
        return output;
    }

    // Calculate total additions for the progress bar
    // Total = pure human + mixed (AI-edited-by-human) + pure AI
    let total_additions = stats.human_additions + stats.ai_additions;

    // Calculate AI acceptance percentage (capped at 100%)
    // It can go higher because AI can write on top of AI code. This feels reasonable for now
    let _ai_acceptance_percentage = if stats.ai_additions > 0 {
        ((stats.ai_accepted as f64 / stats.ai_additions as f64) * 100.0).min(100.0)
    } else {
        0.0
    };

    // Create progress bar with three categories
    // Pure human = human_additions - mixed_additions (overridden lines)
    let pure_human = stats.human_additions.saturating_sub(stats.mixed_additions);

    let pure_human_bars = if total_additions > 0 {
        ((pure_human as f64 / total_additions as f64) * bar_width as f64) as usize
    } else {
        0
    };

    #[allow(unused_variables)]
    let mixed_bars = if total_additions > 0 {
        ((stats.mixed_additions as f64 / total_additions as f64) * bar_width as f64) as usize
    } else {
        0
    };

    #[allow(unused_variables)]
    let ai_bars = if total_additions > 0 {
        ((stats.ai_additions as f64 / total_additions as f64) * bar_width as f64) as usize
    } else {
        0
    };

    // Ensure human contributions get at least 2 visible blocks if they have more than 1 line
    let min_human_bars = if stats.human_additions > 1 { 2 } else { 0 };
    let final_pure_human_bars = if stats.human_additions > 1 {
        pure_human_bars.max(min_human_bars)
    } else {
        pure_human_bars
    };

    // Adjust other bars if we had to give more space to human
    let remaining_width = bar_width.saturating_sub(final_pure_human_bars);
    let total_other_additions = stats.mixed_additions + stats.ai_additions;

    let final_mixed_bars = if total_other_additions > 0 {
        ((stats.mixed_additions as f64 / total_other_additions as f64) * remaining_width as f64)
            as usize
    } else {
        0
    };

    let final_ai_bars = remaining_width.saturating_sub(final_mixed_bars);

    // Build the progress bar with three categories
    let mut progress_bar = String::new();
    progress_bar.push_str("you  ");

    // Pure human bars (darkest)
    progress_bar.push_str(&"‚ñà".repeat(final_pure_human_bars));

    // Mixed bars (medium) - AI-generated but human-edited
    progress_bar.push_str(&"‚ñí".repeat(final_mixed_bars));

    // AI bars (lightest) - pure AI, untouched
    progress_bar.push_str(&"‚ñë".repeat(final_ai_bars));

    progress_bar.push_str(" ai");

    // Format time waiting for AI
    #[allow(unused_variables)]
    let waiting_time_str = if stats.time_waiting_for_ai > 0 {
        let minutes = stats.time_waiting_for_ai / 60;
        let seconds = stats.time_waiting_for_ai % 60;
        if minutes > 0 {
            format!("{}m {}s", minutes, seconds)
        } else {
            format!("{}s", seconds)
        }
    } else {
        "0s".to_string()
    };

    // Calculate percentages for display
    let pure_human_percentage = if total_additions > 0 {
        ((pure_human as f64 / total_additions as f64) * 100.0).round() as u32
    } else {
        0
    };
    let mixed_percentage = if total_additions > 0 {
        ((stats.mixed_additions as f64 / total_additions as f64) * 100.0).round() as u32
    } else {
        0
    };
    let ai_percentage = if total_additions > 0 {
        ((stats.ai_additions as f64 / total_additions as f64) * 100.0).round() as u32
    } else {
        0
    };

    // Print the stats
    output.push_str(&progress_bar);
    output.push('\n');
    if print {
        println!("{}", progress_bar);
    }
    // Print percentage line with proper spacing (40 columns total)
    // "you  " (5) + 40 chars + " ai" (3) = 48 total
    // Human% left-aligned at left edge of bar, AI% right-aligned at right edge of bar
    if mixed_percentage > 0 {
        // Show all three: human, mixed, ai
        // Human% at left edge, mixed% in middle, AI% at right edge
        let percentage_line = format!(
            "     {:<3}{:>12}mixed {:>3}%{:>12}{:>3}%",
            format!("{}%", pure_human_percentage),
            "",
            mixed_percentage,
            "",
            ai_percentage
        );
        output.push_str(&percentage_line);
        output.push('\n');
        if print {
            println!("{}", percentage_line);
        }
    } else {
        // No mixed, just show human and ai at bar edges
        let percentage_line = format!(
            "     {:<3}{:>33}{:>3}%",
            format!("{}%", pure_human_percentage),
            "",
            ai_percentage
        );
        output.push_str(&percentage_line);
        output.push('\n');
        if print {
            println!("{}", percentage_line);
        }
    }

    // Only show AI stats if there was actually AI code
    if stats.ai_additions > 0 {
        let waiting_time_str = if stats.time_waiting_for_ai > 0 {
            let minutes = stats.time_waiting_for_ai / 60;
            let seconds = stats.time_waiting_for_ai % 60;
            if minutes > 0 {
                format!(" | waited {}m for ai", minutes)
            } else {
                format!(" | waited {}s for ai", seconds)
            }
        } else {
            "".to_string()
        };

        let ai_acceptance_str = format!(
            "     \x1b[90m{:.0}% AI code accepted{}\x1b[0m",
            _ai_acceptance_percentage, waiting_time_str
        );
        output.push_str(&ai_acceptance_str);
        output.push('\n');
        if print {
            println!("{}", ai_acceptance_str);
        }
    }
    output
}

#[allow(dead_code)]
pub fn write_stats_to_markdown(stats: &CommitStats) -> String {
    let mut output = String::new();

    // Set maximum bar width to 20 characters
    let bar_width: usize = 20;

    // Handle deletion-only commits (no additions)
    if stats.git_diff_added_lines == 0 && stats.git_diff_deleted_lines > 0 {
        output.push_str("(no additions)");
        output.push('\n');
        return output;
    }

    // Calculate total additions for the progress bar
    // Total = pure human + mixed (AI-edited-by-human) + pure AI (accepted)
    let total_additions = stats.git_diff_added_lines;

    // Pure human additions (not including mixed)
    let pure_human = stats.human_additions;
    // Mixed = AI lines that were edited by human
    let mixed = stats.mixed_additions;
    // Pure AI = AI lines accepted without changes
    let pure_ai = stats.ai_accepted;

    // Calculate percentages for display
    let pure_human_percentage = if total_additions > 0 {
        ((pure_human as f64 / total_additions as f64) * 100.0).round() as u32
    } else {
        0
    };
    let mixed_percentage = if total_additions > 0 {
        ((mixed as f64 / total_additions as f64) * 100.0).round() as u32
    } else {
        0
    };
    let ai_percentage = if total_additions > 0 {
        ((pure_ai as f64 / total_additions as f64) * 100.0).round() as u32
    } else {
        0
    };

    // Calculate bar sizes
    let pure_human_bars = if total_additions > 0 {
        let calculated =
            ((pure_human as f64 / total_additions as f64) * bar_width as f64).round() as usize;
        // Ensure at least 1 block if value > 0
        if pure_human > 0 && calculated == 0 {
            1
        } else {
            calculated
        }
    } else {
        0
    };

    let mixed_bars = if total_additions > 0 {
        let calculated =
            ((mixed as f64 / total_additions as f64) * bar_width as f64).round() as usize;
        // Ensure at least 1 block if value > 0
        if mixed > 0 && calculated == 0 {
            1
        } else {
            calculated
        }
    } else {
        0
    };

    let ai_bars = if total_additions > 0 {
        let calculated =
            ((pure_ai as f64 / total_additions as f64) * bar_width as f64).round() as usize;
        // Ensure at least 1 block if value > 0
        if pure_ai > 0 && calculated == 0 {
            1
        } else {
            calculated
        }
    } else {
        0
    };

    output.push_str("Stats powered by [Git AI](https://github.com/git-ai-project/git-ai)\n\n");
    // Build the fenced code block
    output.push_str("```text\n");

    // Human line: dark blocks for human, light blocks for rest
    output.push_str("üß† you    ");
    output.push_str(&"‚ñà".repeat(pure_human_bars));
    output.push_str(&"‚ñë".repeat(bar_width.saturating_sub(pure_human_bars)));
    output.push_str(&format!("  {}%\n", pure_human_percentage));

    // Mixed line: light blocks for non-mixed, dark blocks for mixed, light blocks for rest
    if mixed_percentage > 0 {
        output.push_str("ü§ù mixed  ");
        output.push_str(&"‚ñë".repeat(pure_human_bars));
        output.push_str(&"‚ñà".repeat(mixed_bars));
        output.push_str(&"‚ñë".repeat(bar_width.saturating_sub(pure_human_bars + mixed_bars)));
        output.push_str(&format!("  {}%\n", mixed_percentage));
    }

    // AI line: light blocks for non-ai, dark blocks for ai
    output.push_str("ü§ñ ai     ");
    output.push_str(&"‚ñë".repeat(bar_width.saturating_sub(ai_bars)));
    output.push_str(&"‚ñà".repeat(ai_bars));
    output.push_str(&format!("  {}%\n", ai_percentage));

    output.push_str("```");

    // Add details section
    output.push_str("\n\n<details>\n");
    output.push_str("<summary>More stats</summary>\n\n");

    // Calculate lines generated per line accepted
    let lines_per_accepted = if stats.ai_accepted > 0 {
        stats.total_ai_additions as f64 / stats.ai_accepted as f64
    } else {
        0.0
    };
    output.push_str(&format!(
        "- {:.1} lines generated for every 1 accepted\n",
        lines_per_accepted
    ));

    let minutes = stats.time_waiting_for_ai / 60;
    let seconds = stats.time_waiting_for_ai % 60;
    let time_str = if minutes > 0 {
        format!("{} minute{}", minutes, if minutes == 1 { "" } else { "s" })
    } else {
        format!("{} second{}", seconds, if seconds == 1 { "" } else { "s" })
    };
    output.push_str(&format!("- {} waiting for AI \n", time_str));
    // Find top model by accepted lines
    if !stats.tool_model_breakdown.is_empty()
        && let Some((model_name, model_stats)) = stats
            .tool_model_breakdown
            .iter()
            .max_by_key(|(_, stats)| stats.ai_accepted)
    {
        output.push_str(&format!(
            "- Top model: {} ({} accepted lines, {} generated lines)\n",
            model_name, model_stats.ai_accepted, model_stats.total_ai_additions
        ));
    }

    output.push_str("\n</details>");

    output
}

/// Calculate commit stats from an authorship log
/// This helper can work with both fetched and in-memory authorship logs
pub fn stats_from_authorship_log(
    authorship_log: Option<&crate::authorship::authorship_log_serialization::AuthorshipLog>,
    git_diff_added_lines: u32,
    git_diff_deleted_lines: u32,
    ai_accepted: u32,
    ai_accepted_by_tool: &BTreeMap<String, u32>,
) -> CommitStats {
    let mut commit_stats = CommitStats {
        human_additions: 0,
        mixed_additions: 0,
        ai_additions: 0,
        ai_accepted,
        total_ai_additions: 0,
        total_ai_deletions: 0,
        time_waiting_for_ai: 0,
        tool_model_breakdown: BTreeMap::new(),
        git_diff_deleted_lines,
        git_diff_added_lines,
    };

    // Process authorship log if present
    if let Some(log) = authorship_log {
        for prompt_record in log.metadata.prompts.values() {
            commit_stats.total_ai_additions += prompt_record.total_additions;
            commit_stats.total_ai_deletions += prompt_record.total_deletions;
            commit_stats.mixed_additions += prompt_record.overriden_lines;

            let key = format!(
                "{}::{}",
                prompt_record.agent_id.tool, prompt_record.agent_id.model
            );
            let tool_stats = commit_stats.tool_model_breakdown.entry(key).or_default();
            tool_stats.total_ai_additions += prompt_record.total_additions;
            tool_stats.total_ai_deletions += prompt_record.total_deletions;
            tool_stats.mixed_additions += prompt_record.overriden_lines;

            // Calculate time waiting for AI from transcript
            // Create a transcript from the messages
            let transcript = crate::authorship::transcript::AiTranscript {
                messages: prompt_record.messages.clone(),
            };
            let waiting = calculate_waiting_time(&transcript);
            commit_stats.time_waiting_for_ai += waiting;
            tool_stats.time_waiting_for_ai += waiting;
        }
    }

    // TODO: Mixed additions come from prompt overrides and can exceed the final diff when we
    // compute ai_accepted from diff/blame. Cap to remaining added lines until we improve mixed tracking.
    let max_mixed = git_diff_added_lines.saturating_sub(commit_stats.ai_accepted);
    if commit_stats.mixed_additions > max_mixed {
        commit_stats.mixed_additions = max_mixed;
    }

    // Update tool-level accepted counts using diff-based attribution.
    for (tool_model, accepted) in ai_accepted_by_tool {
        let tool_stats = commit_stats
            .tool_model_breakdown
            .entry(tool_model.clone())
            .or_default();
        tool_stats.ai_accepted = *accepted;
    }

    // AI additions are the sum of mixed and accepted lines.
    commit_stats.ai_additions = commit_stats.mixed_additions + commit_stats.ai_accepted;

    // Calculate ai_additions for each tool following the same contract: ai_additions = ai_accepted + mixed_additions
    for tool_stats in commit_stats.tool_model_breakdown.values_mut() {
        tool_stats.ai_additions = tool_stats.ai_accepted + tool_stats.mixed_additions;
    }

    // Human additions are the difference between total git diff and AI accepted lines (ensure non-negative)
    // This includes mixed lines (AI-generated but human-edited) as human additions
    commit_stats.human_additions = std::cmp::max(
        0,
        git_diff_added_lines.saturating_sub(commit_stats.ai_accepted),
    );

    commit_stats
}

pub fn stats_for_commit_stats(
    repo: &Repository,
    commit_sha: &str,
    ignore_patterns: &[String],
) -> Result<CommitStats, GitAiError> {
    let commit_obj = repo.revparse_single(commit_sha)?.peel_to_commit()?;

    // Step 1: get the diff between this commit and its parent ON refname (if more than one parent)
    // If initial than everything is additions
    // We want the count here git shows +111 -55
    let (git_diff_added_lines, git_diff_deleted_lines) =
        get_git_diff_stats(repo, commit_sha, ignore_patterns)?;

    // Step 2: get the authorship log for this commit
    let authorship_log = get_authorship(repo, commit_sha);

    // Step 3: get line numbers added by this specific commit, then intersect with attestations.
    // This keeps accepted stats scoped to the target commit while avoiding expensive blame traversal.
    let parent_count = commit_obj.parent_count()?;
    let is_merge_commit = parent_count > 1;
    let mut added_lines_by_file: HashMap<String, Vec<u32>> = if is_merge_commit {
        HashMap::new()
    } else {
        let from_ref = if parent_count == 0 {
            "4b825dc642cb6eb9a060e54bf8d69288fbee4904".to_string()
        } else {
            commit_obj.parent(0)?.id()
        };
        repo.diff_added_lines(&from_ref, commit_sha, None)?
    };
    let ignore_matcher = build_ignore_matcher(ignore_patterns);
    added_lines_by_file
        .retain(|file_path, _| !should_ignore_file_with_matcher(file_path, &ignore_matcher));
    for lines in added_lines_by_file.values_mut() {
        lines.sort_unstable();
        lines.dedup();
    }

    // Step 4: derive accepted lines directly from note attestations for lines added in this commit.
    let (ai_accepted, ai_accepted_by_tool) = accepted_lines_from_attestations(
        authorship_log.as_ref(),
        &added_lines_by_file,
        is_merge_commit,
    );

    // Step 5: Calculate stats from authorship log
    Ok(stats_from_authorship_log(
        authorship_log.as_ref(),
        git_diff_added_lines,
        git_diff_deleted_lines,
        ai_accepted,
        &ai_accepted_by_tool,
    ))
}

fn accepted_lines_from_attestations(
    authorship_log: Option<&crate::authorship::authorship_log_serialization::AuthorshipLog>,
    added_lines_by_file: &HashMap<String, Vec<u32>>,
    is_merge_commit: bool,
) -> (u32, BTreeMap<String, u32>) {
    if is_merge_commit {
        return (0, BTreeMap::new());
    }

    let mut total_ai_accepted = 0u32;
    let mut per_tool_model = BTreeMap::new();

    let Some(log) = authorship_log else {
        return (0, per_tool_model);
    };

    for file_attestation in &log.attestations {
        let Some(added_lines) = added_lines_by_file.get(&file_attestation.file_path) else {
            continue;
        };

        for entry in &file_attestation.entries {
            let accepted = entry
                .line_ranges
                .iter()
                .map(|line_range| line_range_overlap_len(line_range, added_lines))
                .sum::<u32>();

            if accepted == 0 {
                continue;
            }

            total_ai_accepted += accepted;

            if let Some(prompt_record) = log.metadata.prompts.get(&entry.hash) {
                let tool_model = format!(
                    "{}::{}",
                    prompt_record.agent_id.tool, prompt_record.agent_id.model
                );
                *per_tool_model.entry(tool_model).or_insert(0) += accepted;
            }
        }
    }

    (total_ai_accepted, per_tool_model)
}

fn line_range_overlap_len(range: &LineRange, added_lines: &[u32]) -> u32 {
    match range {
        LineRange::Single(line) => u32::from(added_lines.binary_search(line).is_ok()),
        LineRange::Range(start, end) => {
            let start_idx = added_lines.partition_point(|line| *line < *start);
            let end_idx = added_lines.partition_point(|line| *line <= *end);
            end_idx.saturating_sub(start_idx) as u32
        }
    }
}

/// Get git diff statistics between commit and its parent
pub fn get_git_diff_stats(
    repo: &Repository,
    commit_sha: &str,
    ignore_patterns: &[String],
) -> Result<(u32, u32), GitAiError> {
    // Use git show --numstat to get diff statistics
    let mut args = repo.global_args_for_exec();
    args.push("show".to_string());
    args.push("--numstat".to_string());
    args.push("--format=".to_string()); // No format, just the numstat
    args.push(commit_sha.to_string());

    let output = crate::git::repository::exec_git(&args)?;
    let stdout = String::from_utf8_lossy(&output.stdout);

    let mut added_lines = 0u32;
    let mut deleted_lines = 0u32;
    let ignore_matcher = build_ignore_matcher(ignore_patterns);

    // Parse numstat output
    for line in stdout.lines() {
        if line.trim().is_empty() {
            continue;
        }

        // Skip the commit message lines (they don't start with numbers)
        if !line.chars().next().is_some_and(|c| c.is_ascii_digit()) {
            continue;
        }

        // Parse numstat format: "added\tdeleted\tfilename"
        let parts: Vec<&str> = line.split('\t').collect();
        if parts.len() >= 3 {
            // Check if this file should be ignored
            let filename = parts[2];
            if should_ignore_file_with_matcher(filename, &ignore_matcher) {
                continue;
            }

            // Parse added lines
            if let Ok(added) = parts[0].parse::<u32>() {
                added_lines += added;
            }

            // Parse deleted lines (handle "-" for binary files)
            if parts[1] != "-"
                && let Ok(deleted) = parts[1].parse::<u32>()
            {
                deleted_lines += deleted;
            }
        }
    }

    Ok((added_lines, deleted_lines))
}

/// Calculate time waiting for AI from transcript messages
fn calculate_waiting_time(transcript: &crate::authorship::transcript::AiTranscript) -> u64 {
    let mut total_waiting_time = 0u64;
    let messages = transcript.messages();

    if messages.len() <= 1 {
        return 0;
    }

    // Check if last message is from human (don't count time if so)
    let last_message_is_human = matches!(messages.last(), Some(Message::User { .. }));
    if last_message_is_human {
        return 0;
    }

    // Sum time between user and AI messages
    let mut i = 0;
    while i < messages.len() - 1 {
        if let (
            Message::User {
                timestamp: Some(user_ts),
                ..
            },
            Message::Assistant {
                timestamp: Some(ai_ts),
                ..
            }
            | Message::Thinking {
                timestamp: Some(ai_ts),
                ..
            }
            | Message::Plan {
                timestamp: Some(ai_ts),
                ..
            },
        ) = (&messages[i], &messages[i + 1])
        {
            // Parse timestamps and calculate difference
            if let (Ok(user_time), Ok(ai_time)) = (
                chrono::DateTime::parse_from_rfc3339(user_ts),
                chrono::DateTime::parse_from_rfc3339(ai_ts),
            ) {
                let duration = ai_time.signed_duration_since(user_time);
                if duration.num_seconds() > 0 {
                    total_waiting_time += duration.num_seconds() as u64;
                }
            }

            i += 2; // Skip to next user message
        } else {
            i += 1;
        }
    }

    total_waiting_time
}

#[cfg(test)]
mod tests {
    use insta::assert_debug_snapshot;

    use super::*;
    use crate::git::test_utils::TmpRepo;

    #[test]
    fn test_terminal_stats_display() {
        // Test with mixed human/AI stats
        let stats = CommitStats {
            human_additions: 50,
            mixed_additions: 40,
            ai_additions: 100,
            ai_accepted: 25,
            time_waiting_for_ai: 72009, // 1 minute 30 seconds
            git_diff_deleted_lines: 15,
            git_diff_added_lines: 80,
            total_ai_additions: 100,
            total_ai_deletions: 0,
            tool_model_breakdown: BTreeMap::new(),
        };

        let mixed_output = write_stats_to_terminal(&stats, true);
        assert_debug_snapshot!(mixed_output);

        // Test with AI-only stats
        let ai_stats = CommitStats {
            human_additions: 0,
            mixed_additions: 0,
            ai_additions: 100,
            ai_accepted: 95,
            time_waiting_for_ai: 45,
            git_diff_deleted_lines: 0,
            git_diff_added_lines: 100,
            total_ai_additions: 100,
            total_ai_deletions: 0,
            tool_model_breakdown: BTreeMap::new(),
        };

        let ai_only_output = write_stats_to_terminal(&ai_stats, true);
        assert_debug_snapshot!(ai_only_output);

        // Test with human-only stats
        let human_stats = CommitStats {
            human_additions: 75,
            mixed_additions: 0,
            ai_additions: 0,
            ai_accepted: 0,
            time_waiting_for_ai: 0,
            git_diff_deleted_lines: 10,
            git_diff_added_lines: 75,
            total_ai_additions: 0,
            total_ai_deletions: 0,
            tool_model_breakdown: BTreeMap::new(),
        };

        let human_only_output = write_stats_to_terminal(&human_stats, true);
        assert_debug_snapshot!(human_only_output);

        // Test with minimal human contribution (should get at least 2 blocks)
        let minimal_human_stats = CommitStats {
            human_additions: 2,
            mixed_additions: 0,
            ai_additions: 100,
            ai_accepted: 95,
            time_waiting_for_ai: 30,
            git_diff_deleted_lines: 0,
            git_diff_added_lines: 102,
            total_ai_additions: 100,
            total_ai_deletions: 0,
            tool_model_breakdown: BTreeMap::new(),
        };

        let minimal_human_output = write_stats_to_terminal(&minimal_human_stats, true);
        assert_debug_snapshot!(minimal_human_output);

        // Test with deletion-only commit (no additions)
        let deletion_only_stats = CommitStats {
            human_additions: 0,
            mixed_additions: 0,
            ai_additions: 0,
            ai_accepted: 0,
            time_waiting_for_ai: 0,
            git_diff_deleted_lines: 25,
            git_diff_added_lines: 0,
            total_ai_additions: 0,
            total_ai_deletions: 0,
            tool_model_breakdown: BTreeMap::new(),
        };

        let deletion_only_output = write_stats_to_terminal(&deletion_only_stats, true);
        assert_debug_snapshot!(deletion_only_output);
    }

    #[test]
    fn test_markdown_stats_display() {
        // Test with mixed human/AI stats
        let stats = CommitStats {
            human_additions: 50,
            mixed_additions: 40,
            ai_additions: 100,
            ai_accepted: 25,
            time_waiting_for_ai: 72009, // 1 minute 30 seconds
            git_diff_deleted_lines: 15,
            git_diff_added_lines: 80,
            total_ai_additions: 100,
            total_ai_deletions: 0,
            tool_model_breakdown: BTreeMap::new(),
        };

        let mixed_output = write_stats_to_markdown(&stats);
        assert_debug_snapshot!(mixed_output);

        // Test with AI-only stats
        let ai_stats = CommitStats {
            human_additions: 0,
            mixed_additions: 0,
            ai_additions: 100,
            ai_accepted: 95,
            time_waiting_for_ai: 45,
            git_diff_deleted_lines: 0,
            git_diff_added_lines: 100,
            total_ai_additions: 100,
            total_ai_deletions: 0,
            tool_model_breakdown: BTreeMap::new(),
        };

        let ai_only_output = write_stats_to_markdown(&ai_stats);
        assert_debug_snapshot!(ai_only_output);

        // Test with human-only stats
        let human_stats = CommitStats {
            human_additions: 75,
            mixed_additions: 0,
            ai_additions: 0,
            ai_accepted: 0,
            time_waiting_for_ai: 0,
            git_diff_deleted_lines: 10,
            git_diff_added_lines: 75,
            total_ai_additions: 0,
            total_ai_deletions: 0,
            tool_model_breakdown: BTreeMap::new(),
        };

        let human_only_output = write_stats_to_markdown(&human_stats);
        assert_debug_snapshot!(human_only_output);

        // Test with minimal human contribution (should get at least 2 blocks)
        let minimal_human_stats = CommitStats {
            human_additions: 2,
            mixed_additions: 0,
            ai_additions: 100,
            ai_accepted: 95,
            time_waiting_for_ai: 30,
            git_diff_deleted_lines: 0,
            git_diff_added_lines: 102,
            total_ai_additions: 100,
            total_ai_deletions: 0,
            tool_model_breakdown: BTreeMap::new(),
        };

        let minimal_human_output = write_stats_to_markdown(&minimal_human_stats);
        assert_debug_snapshot!(minimal_human_output);

        // Test with deletion-only commit (no additions)
        let deletion_only_stats = CommitStats {
            human_additions: 0,
            mixed_additions: 0,
            ai_additions: 0,
            ai_accepted: 0,
            time_waiting_for_ai: 0,
            git_diff_deleted_lines: 25,
            git_diff_added_lines: 0,
            total_ai_additions: 0,
            total_ai_deletions: 0,
            tool_model_breakdown: BTreeMap::new(),
        };

        let deletion_only_output = write_stats_to_markdown(&deletion_only_stats);
        assert_debug_snapshot!(deletion_only_output);
    }

    #[test]
    fn test_stats_for_simple_ai_commit() {
        let tmp_repo = TmpRepo::new().unwrap();

        let mut file = tmp_repo.write_file("test.txt", "Line1\n", true).unwrap();

        tmp_repo
            .trigger_checkpoint_with_author("test_user")
            .unwrap();

        tmp_repo.commit_with_message("Initial commit").unwrap();

        // AI adds 2 lines
        file.append("Line 2\nLine 3\n").unwrap();

        tmp_repo
            .trigger_checkpoint_with_ai("Claude", Some("claude-3-sonnet"), Some("cursor"))
            .unwrap();

        tmp_repo.commit_with_message("AI adds lines").unwrap();

        // Get the commit SHA for the AI commit
        let head_sha = tmp_repo.get_head_commit_sha().unwrap();

        // Test our stats function
        let stats = stats_for_commit_stats(tmp_repo.gitai_repo(), &head_sha, &[]).unwrap();

        // Verify the stats
        assert_eq!(
            stats.human_additions, 0,
            "No human additions in AI-only commit"
        );
        assert_eq!(stats.ai_additions, 2, "AI added 2 lines");
        assert_eq!(stats.ai_accepted, 2, "AI lines were accepted");
        assert_eq!(
            stats.git_diff_added_lines, 2,
            "Git diff shows 2 added lines"
        );
        assert_eq!(
            stats.git_diff_deleted_lines, 0,
            "Git diff shows 0 deleted lines"
        );
        assert_eq!(
            stats.time_waiting_for_ai, 0,
            "No waiting time recorded (no timestamps in test)"
        );
    }

    #[test]
    fn test_stats_for_mixed_commit() {
        let tmp_repo = TmpRepo::new().unwrap();

        let mut file = tmp_repo
            .write_file("test.txt", "Base line\n", true)
            .unwrap();

        tmp_repo
            .trigger_checkpoint_with_author("test_user")
            .unwrap();

        tmp_repo.commit_with_message("Initial commit").unwrap();

        // AI adds lines
        file.append("AI line 1\nAI line 2\n").unwrap();
        tmp_repo
            .trigger_checkpoint_with_ai("Claude", Some("claude-3-sonnet"), Some("cursor"))
            .unwrap();

        // Human adds lines
        file.append("Human line 1\nHuman line 2\n").unwrap();
        tmp_repo
            .trigger_checkpoint_with_author("test_user")
            .unwrap();

        tmp_repo.commit_with_message("Mixed commit").unwrap();

        let head_sha = tmp_repo.get_head_commit_sha().unwrap();
        let stats = stats_for_commit_stats(tmp_repo.gitai_repo(), &head_sha, &[]).unwrap();

        // Verify the stats
        assert_eq!(stats.human_additions, 2, "Human added 2 lines");
        assert_eq!(stats.ai_additions, 2, "AI added 2 lines");
        assert_eq!(stats.ai_accepted, 2, "AI lines were accepted");
        assert_eq!(
            stats.git_diff_added_lines, 4,
            "Git diff shows 4 added lines total"
        );
        assert_eq!(
            stats.git_diff_deleted_lines, 0,
            "Git diff shows 0 deleted lines"
        );
    }

    #[test]
    fn test_stats_for_initial_commit() {
        let tmp_repo = TmpRepo::new().unwrap();

        let _file = tmp_repo
            .write_file("test.txt", "Line1\nLine2\nLine3\n", true)
            .unwrap();

        tmp_repo
            .trigger_checkpoint_with_author("test_user")
            .unwrap();

        tmp_repo.commit_with_message("Initial commit").unwrap();

        let head_sha = tmp_repo.get_head_commit_sha().unwrap();
        let stats = stats_for_commit_stats(tmp_repo.gitai_repo(), &head_sha, &[]).unwrap();

        // For initial commit, everything should be additions
        assert_eq!(
            stats.human_additions, 3,
            "Human authored 3 lines in initial commit"
        );
        assert_eq!(stats.ai_additions, 0, "No AI additions in initial commit");
        assert_eq!(stats.ai_accepted, 0, "No AI lines to accept");
        assert_eq!(
            stats.git_diff_added_lines, 3,
            "Git diff shows 3 added lines (initial commit)"
        );
        assert_eq!(
            stats.git_diff_deleted_lines, 0,
            "Git diff shows 0 deleted lines"
        );
    }

    #[test]
    fn test_stats_ignores_single_lockfile() {
        let tmp_repo = TmpRepo::new().unwrap();

        // Initial commit
        tmp_repo
            .write_file("src/main.rs", "fn main() {}\n", true)
            .unwrap();
        tmp_repo
            .trigger_checkpoint_with_author("test_user")
            .unwrap();
        tmp_repo.commit_with_message("Initial commit").unwrap();

        // Commit that adds source code and a large lockfile
        tmp_repo
            .write_file("src/main.rs", "fn main() {}\nfn helper() {}\n", true)
            .unwrap();
        tmp_repo
            .write_file("Cargo.lock", "# lockfile\n".repeat(1000).as_str(), true)
            .unwrap();
        tmp_repo
            .trigger_checkpoint_with_ai("Claude", Some("claude-3-sonnet"), Some("cursor"))
            .unwrap();
        tmp_repo.commit_with_message("Add helper and deps").unwrap();

        let head_sha = tmp_repo.get_head_commit_sha().unwrap();

        // Test WITHOUT ignore - should count lockfile
        let stats_with_lockfile =
            stats_for_commit_stats(tmp_repo.gitai_repo(), &head_sha, &[]).unwrap();
        assert_eq!(stats_with_lockfile.git_diff_added_lines, 1001); // 1 source + 1000 lockfile

        // Test WITH ignore - should exclude lockfile
        let ignore_patterns = vec!["Cargo.lock".to_string()];
        let stats_without_lockfile =
            stats_for_commit_stats(tmp_repo.gitai_repo(), &head_sha, &ignore_patterns).unwrap();
        assert_eq!(stats_without_lockfile.git_diff_added_lines, 1); // Only 1 source line
        assert_eq!(stats_without_lockfile.ai_additions, 1);
    }

    #[test]
    fn test_stats_ignores_multiple_lockfiles() {
        let tmp_repo = TmpRepo::new().unwrap();

        // Initial commit
        tmp_repo
            .write_file("README.md", "# Project\n", true)
            .unwrap();
        tmp_repo
            .trigger_checkpoint_with_author("test_user")
            .unwrap();
        tmp_repo.commit_with_message("Initial commit").unwrap();

        // Commit that updates multiple lockfiles and one source file
        tmp_repo
            .write_file("README.md", "# Project\n## New\n", true)
            .unwrap();
        tmp_repo
            .write_file("Cargo.lock", "# cargo\n".repeat(500).as_str(), true)
            .unwrap();
        tmp_repo
            .write_file("package-lock.json", "{}\n".repeat(500).as_str(), true)
            .unwrap();
        tmp_repo
            .write_file("yarn.lock", "# yarn\n".repeat(500).as_str(), true)
            .unwrap();
        tmp_repo
            .trigger_checkpoint_with_author("test_user")
            .unwrap();
        tmp_repo.commit_with_message("Update deps").unwrap();

        let head_sha = tmp_repo.get_head_commit_sha().unwrap();

        // Test WITHOUT ignore - counts all files (1501 lines)
        let stats_all = stats_for_commit_stats(tmp_repo.gitai_repo(), &head_sha, &[]).unwrap();
        assert_eq!(stats_all.git_diff_added_lines, 1501);

        // Test WITH ignore - only counts README (1 line)
        let ignore_patterns = vec![
            "Cargo.lock".to_string(),
            "package-lock.json".to_string(),
            "yarn.lock".to_string(),
        ];
        let stats_filtered =
            stats_for_commit_stats(tmp_repo.gitai_repo(), &head_sha, &ignore_patterns).unwrap();
        assert_eq!(stats_filtered.git_diff_added_lines, 1);
        assert_eq!(stats_filtered.human_additions, 1);
    }

    #[test]
    fn test_stats_with_lockfile_only_commit() {
        let tmp_repo = TmpRepo::new().unwrap();

        // Initial commit
        tmp_repo
            .write_file("src/lib.rs", "pub fn foo() {}\n", true)
            .unwrap();
        tmp_repo
            .trigger_checkpoint_with_author("test_user")
            .unwrap();
        tmp_repo.commit_with_message("Initial commit").unwrap();

        // Commit that ONLY updates lockfiles (common during dependency updates)
        tmp_repo
            .write_file("Cargo.lock", "# updated\n".repeat(2000).as_str(), true)
            .unwrap();
        tmp_repo
            .trigger_checkpoint_with_author("test_user")
            .unwrap();
        tmp_repo.commit_with_message("Update dependencies").unwrap();

        let head_sha = tmp_repo.get_head_commit_sha().unwrap();

        // Test WITHOUT ignore - shows 2000 lines
        let stats_with = stats_for_commit_stats(tmp_repo.gitai_repo(), &head_sha, &[]).unwrap();
        assert_eq!(stats_with.git_diff_added_lines, 2000);

        // Test WITH ignore - shows 0 lines (lockfile-only commit)
        let ignore_patterns = vec!["Cargo.lock".to_string()];
        let stats_without =
            stats_for_commit_stats(tmp_repo.gitai_repo(), &head_sha, &ignore_patterns).unwrap();
        assert_eq!(stats_without.git_diff_added_lines, 0);
        assert_eq!(stats_without.ai_additions, 0);
        assert_eq!(stats_without.human_additions, 0);
    }

    #[test]
    fn test_stats_empty_ignore_patterns() {
        let tmp_repo = TmpRepo::new().unwrap();

        // Initial commit
        tmp_repo.write_file("test.txt", "Line1\n", true).unwrap();
        tmp_repo
            .trigger_checkpoint_with_author("test_user")
            .unwrap();
        tmp_repo.commit_with_message("Initial commit").unwrap();

        // Add lines
        tmp_repo
            .write_file("test.txt", "Line1\nLine2\nLine3\n", true)
            .unwrap();
        tmp_repo
            .trigger_checkpoint_with_ai("Claude", Some("claude-3-sonnet"), Some("cursor"))
            .unwrap();
        tmp_repo.commit_with_message("Add lines").unwrap();

        let head_sha = tmp_repo.get_head_commit_sha().unwrap();

        // Test with empty patterns - should behave same as no filtering
        let stats = stats_for_commit_stats(tmp_repo.gitai_repo(), &head_sha, &[]).unwrap();
        assert_eq!(stats.git_diff_added_lines, 2);
        assert_eq!(stats.ai_additions, 2);
    }

    #[test]
    fn test_stats_with_glob_patterns() {
        let tmp_repo = TmpRepo::new().unwrap();

        // Initial commit
        tmp_repo
            .write_file("src/lib.rs", "pub fn foo() {}\n", true)
            .unwrap();
        tmp_repo
            .trigger_checkpoint_with_author("test_user")
            .unwrap();
        tmp_repo.commit_with_message("Initial commit").unwrap();

        // Commit with source code + lockfiles + generated files
        tmp_repo
            .write_file("src/lib.rs", "pub fn foo() {}\npub fn bar() {}\n", true)
            .unwrap();
        tmp_repo
            .write_file("Cargo.lock", "# lock\n".repeat(1000).as_str(), true)
            .unwrap();
        tmp_repo
            .write_file("package-lock.json", "{}\n".repeat(500).as_str(), true)
            .unwrap();
        tmp_repo
            .write_file(
                "api.generated.ts",
                "// generated\n".repeat(300).as_str(),
                true,
            )
            .unwrap();
        tmp_repo
            .write_file(
                "schema.generated.js",
                "// schema\n".repeat(200).as_str(),
                true,
            )
            .unwrap();
        tmp_repo
            .trigger_checkpoint_with_ai("Claude", Some("claude-3-sonnet"), Some("cursor"))
            .unwrap();
        tmp_repo.commit_with_message("Add code").unwrap();

        let head_sha = tmp_repo.get_head_commit_sha().unwrap();

        // Test WITHOUT ignore - all files included (2001 lines)
        let stats_all = stats_for_commit_stats(tmp_repo.gitai_repo(), &head_sha, &[]).unwrap();
        assert_eq!(stats_all.git_diff_added_lines, 2001);

        // Test WITH glob patterns - only source code (1 line)
        let glob_patterns = vec![
            "*.lock".to_string(),        // Matches Cargo.lock
            "*lock.json".to_string(),    // Matches package-lock.json
            "*.generated.*".to_string(), // Matches *.generated.ts, *.generated.js
        ];
        let stats_filtered =
            stats_for_commit_stats(tmp_repo.gitai_repo(), &head_sha, &glob_patterns).unwrap();
        assert_eq!(stats_filtered.git_diff_added_lines, 1);
        assert_eq!(stats_filtered.ai_additions, 1);
    }
    #[test]
    fn test_accepted_lines_no_authorship_log() {
        let added_lines: HashMap<String, Vec<u32>> = HashMap::new();
        let (accepted, per_tool) = accepted_lines_from_attestations(None, &added_lines, false);
        assert_eq!(accepted, 0);
        assert!(per_tool.is_empty());
    }

    #[test]
    fn test_accepted_lines_merge_commit() {
        // Even with a real authorship log, merge commits should short-circuit to (0, empty)
        let mut log = crate::authorship::authorship_log_serialization::AuthorshipLog::new();
        let agent_id = crate::authorship::working_log::AgentId {
            tool: "cursor".to_string(),
            id: "session_1".to_string(),
            model: "claude-3-sonnet".to_string(),
        };
        let hash = crate::authorship::authorship_log_serialization::generate_short_hash(
            &agent_id.id,
            &agent_id.tool,
        );
        log.metadata.prompts.insert(
            hash.clone(),
            crate::authorship::authorship_log::PromptRecord {
                agent_id,
                human_author: None,
                messages: vec![],
                total_additions: 5,
                total_deletions: 0,
                accepted_lines: 5,
                overriden_lines: 0,
                messages_url: None,
            },
        );

        let mut file_att = crate::authorship::authorship_log_serialization::FileAttestation::new(
            "foo.rs".to_string(),
        );
        file_att.add_entry(
            crate::authorship::authorship_log_serialization::AttestationEntry::new(
                hash,
                vec![crate::authorship::authorship_log::LineRange::Range(1, 3)],
            ),
        );
        log.attestations.push(file_att);

        let mut added_lines: HashMap<String, Vec<u32>> = HashMap::new();
        added_lines.insert("foo.rs".to_string(), vec![1, 2, 3]);

        let (accepted, per_tool) = accepted_lines_from_attestations(Some(&log), &added_lines, true);
        assert_eq!(accepted, 0);
        assert!(per_tool.is_empty());
    }

    #[test]
    fn test_accepted_lines_no_matching_files() {
        let mut log = crate::authorship::authorship_log_serialization::AuthorshipLog::new();
        let agent_id = crate::authorship::working_log::AgentId {
            tool: "cursor".to_string(),
            id: "session_2".to_string(),
            model: "claude-3-sonnet".to_string(),
        };
        let hash = crate::authorship::authorship_log_serialization::generate_short_hash(
            &agent_id.id,
            &agent_id.tool,
        );
        log.metadata.prompts.insert(
            hash.clone(),
            crate::authorship::authorship_log::PromptRecord {
                agent_id,
                human_author: None,
                messages: vec![],
                total_additions: 3,
                total_deletions: 0,
                accepted_lines: 3,
                overriden_lines: 0,
                messages_url: None,
            },
        );

        let mut file_att = crate::authorship::authorship_log_serialization::FileAttestation::new(
            "foo.rs".to_string(),
        );
        file_att.add_entry(
            crate::authorship::authorship_log_serialization::AttestationEntry::new(
                hash,
                vec![crate::authorship::authorship_log::LineRange::Range(1, 3)],
            ),
        );
        log.attestations.push(file_att);

        // added_lines has "bar.rs" but NOT "foo.rs"
        let mut added_lines: HashMap<String, Vec<u32>> = HashMap::new();
        added_lines.insert("bar.rs".to_string(), vec![1, 2, 3]);

        let (accepted, per_tool) =
            accepted_lines_from_attestations(Some(&log), &added_lines, false);
        assert_eq!(accepted, 0);
        assert!(per_tool.is_empty());
    }

    #[test]
    fn test_accepted_lines_basic_match() {
        let mut log = crate::authorship::authorship_log_serialization::AuthorshipLog::new();
        let agent_id = crate::authorship::working_log::AgentId {
            tool: "cursor".to_string(),
            id: "session_3".to_string(),
            model: "claude-3-sonnet".to_string(),
        };
        let hash = crate::authorship::authorship_log_serialization::generate_short_hash(
            &agent_id.id,
            &agent_id.tool,
        );
        log.metadata.prompts.insert(
            hash.clone(),
            crate::authorship::authorship_log::PromptRecord {
                agent_id,
                human_author: None,
                messages: vec![],
                total_additions: 3,
                total_deletions: 0,
                accepted_lines: 3,
                overriden_lines: 0,
                messages_url: None,
            },
        );

        let mut file_att = crate::authorship::authorship_log_serialization::FileAttestation::new(
            "foo.rs".to_string(),
        );
        file_att.add_entry(
            crate::authorship::authorship_log_serialization::AttestationEntry::new(
                hash.clone(),
                vec![crate::authorship::authorship_log::LineRange::Range(1, 3)],
            ),
        );
        log.attestations.push(file_att);

        let mut added_lines: HashMap<String, Vec<u32>> = HashMap::new();
        added_lines.insert("foo.rs".to_string(), vec![1, 2, 3]);

        let (accepted, per_tool) =
            accepted_lines_from_attestations(Some(&log), &added_lines, false);
        assert_eq!(accepted, 3);

        // Verify per-tool breakdown contains the right key
        let expected_key = "cursor::claude-3-sonnet".to_string();
        assert_eq!(per_tool.get(&expected_key), Some(&3));
    }

    // --- line_range_overlap_len tests ---

    #[test]
    fn test_overlap_single_hit() {
        let count = line_range_overlap_len(&LineRange::Single(5), &[3, 5, 7]);
        assert_eq!(count, 1);
    }

    #[test]
    fn test_overlap_single_miss() {
        let count = line_range_overlap_len(&LineRange::Single(4), &[3, 5, 7]);
        assert_eq!(count, 0);
    }

    #[test]
    fn test_overlap_range_full() {
        let count = line_range_overlap_len(&LineRange::Range(3, 7), &[3, 4, 5, 6, 7]);
        assert_eq!(count, 5);
    }

    #[test]
    fn test_overlap_range_partial() {
        // Range [4, 8] intersected with [3, 5, 7, 9]: only 5 and 7 are in range
        let count = line_range_overlap_len(&LineRange::Range(4, 8), &[3, 5, 7, 9]);
        assert_eq!(count, 2);
    }

    #[test]
    fn test_overlap_range_miss() {
        let count = line_range_overlap_len(&LineRange::Range(10, 20), &[1, 2, 3]);
        assert_eq!(count, 0);
    }

    #[test]
    fn test_overlap_range_empty_added() {
        let count = line_range_overlap_len(&LineRange::Range(1, 10), &[]);
        assert_eq!(count, 0);
    }

    #[test]
    fn test_stats_for_merge_commit_skips_ai_acceptance() {
        let tmp_repo = TmpRepo::new().unwrap();

        tmp_repo.write_file("test.txt", "base\n", true).unwrap();
        tmp_repo
            .trigger_checkpoint_with_author("test_user")
            .unwrap();
        tmp_repo.commit_with_message("Initial commit").unwrap();

        let default_branch = tmp_repo.current_branch().unwrap();
        tmp_repo.create_branch("feature").unwrap();
        tmp_repo
            .write_file("test.txt", "base\nfeature line\n", true)
            .unwrap();
        tmp_repo
            .trigger_checkpoint_with_ai("Claude", Some("claude-3-sonnet"), Some("cursor"))
            .unwrap();
        tmp_repo.commit_with_message("Feature change").unwrap();

        tmp_repo.switch_branch(&default_branch).unwrap();
        tmp_repo
            .write_file("main.txt", "main line\n", true)
            .unwrap();
        tmp_repo
            .trigger_checkpoint_with_author("test_user")
            .unwrap();
        tmp_repo.commit_with_message("Main change").unwrap();

        tmp_repo.merge_branch("feature", "Merge feature").unwrap();

        let merge_sha = tmp_repo.get_head_commit_sha().unwrap();
        let stats = stats_for_commit_stats(tmp_repo.gitai_repo(), &merge_sha, &[]).unwrap();

        assert_eq!(stats.ai_accepted, 0);
        assert_eq!(stats.ai_additions, stats.mixed_additions);
    }
}
