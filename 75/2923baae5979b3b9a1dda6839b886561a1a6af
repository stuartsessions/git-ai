src/commands/checkpoint_agent/agent_presets.rs
  ae98a0e43b399cac 166-172,191,215,222
---
{
  "schema_version": "authorship/3.0.0",
  "git_ai_version": "development:1.0.22",
  "base_commit_sha": "752923baae5979b3b9a1dda6839b886561a1a6af",
  "prompts": {
    "ae98a0e43b399cac": {
      "agent_id": {
        "tool": "claude",
        "id": "4c3e6938-0ec6-42bf-8210-9ce486c27c03",
        "model": "claude-sonnet-4-5-20250929"
      },
      "human_author": "Sasha Varlamov <sasha@sashavarlamov.com>",
      "messages": [
        {
          "type": "user",
          "text": "Reference\nCommon schema\nInput (all hooks)\nAll hooks receive a base set of fields in addition to their hook-specific fields:\n\n\n{\n  \"conversation_id\": \"string\",\n  \"generation_id\": \"string\",\n  \"model\": \"string\",\n  \"hook_event_name\": \"string\",\n  \"cursor_version\": \"string\",\n  \"workspace_roots\": [\"<path>\"],\n  \"user_email\": \"string | null\"\n}\nField    Type    Description\nconversation_id    string    Stable ID of the conversation across many turns\ngeneration_id    string    The current generation that changes with every user message\nmodel    string    The model configured for the composer that triggered the hook\nhook_event_name    string    Which hook is being run\ncursor_version    string    Cursor application version (e.g. \"1.7.2\")\nworkspace_roots    string[]    The list of root folders in the workspace (normally just one, but multiroot workspaces can have multiple)\nuser_email    string | null    Email address of the authenticated user, if available\n\nCursor hooks actually send us the model directly in the hook input data. Update our cursor agent preset to use this value for the model in the agent id (instead of pulling the model from the sqlite db data)",
          "timestamp": "2025-12-03T21:13:27.564Z"
        },
        {
          "type": "assistant",
          "text": "I'll help you update the cursor agent preset to use the model from the hook input data instead of pulling it from the sqlite database. Let me first read the current implementation.",
          "timestamp": "2025-12-03T21:13:33.295Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/Users/svarlamov/projects/git-ai/src/commands/checkpoint_agent/agent_presets.rs"
          },
          "timestamp": "2025-12-03T21:13:33.880Z"
        },
        {
          "type": "user",
          "text": "     1→use crate::{\n     2→    authorship::{\n     3→        transcript::{AiTranscript, Message},\n     4→        working_log::{AgentId, CheckpointKind},\n     5→    },\n     6→    error::GitAiError,\n     7→};\n     8→use chrono::{TimeZone, Utc};\n     9→use rusqlite::{Connection, OpenFlags};\n    10→use serde::Deserialize;\n    11→use std::collections::HashMap;\n    12→use std::env;\n    13→use std::path::{Path, PathBuf};\n    14→\n    15→pub struct AgentCheckpointFlags {\n    16→    pub hook_input: Option<String>,\n    17→}\n    18→\n    19→#[derive(Clone, Debug)]\n    20→pub struct AgentRunResult {\n    21→    pub agent_id: AgentId,\n    22→    pub agent_metadata: Option<HashMap<String, String>>,\n    23→    pub checkpoint_kind: CheckpointKind,\n    24→    pub transcript: Option<AiTranscript>,\n    25→    pub repo_working_dir: Option<String>,\n    26→    pub edited_filepaths: Option<Vec<String>>,\n    27→    pub will_edit_filepaths: Option<Vec<String>>,\n    28→    pub dirty_files: Option<HashMap<String, String>>,\n    29→}\n    30→\n    31→pub trait AgentCheckpointPreset {\n    32→    fn run(&self, flags: AgentCheckpointFlags) -> Result<AgentRunResult, GitAiError>;\n    33→}\n    34→\n    35→// Claude Code to checkpoint preset\n    36→pub struct ClaudePreset;\n    37→\n    38→impl AgentCheckpointPreset for ClaudePreset {\n    39→    fn run(&self, flags: AgentCheckpointFlags) -> Result<AgentRunResult, GitAiError> {\n    40→        // Parse claude_hook_stdin as JSON\n    41→        let stdin_json = flags.hook_input.ok_or_else(|| {\n    42→            GitAiError::PresetError(\"hook_input is required for Claude preset\".to_string())\n    43→        })?;\n    44→\n    45→        let hook_data: serde_json::Value = serde_json::from_str(&stdin_json)\n    46→            .map_err(|e| GitAiError::PresetError(format!(\"Invalid JSON in hook_input: {}\", e)))?;\n    47→\n    48→        // Extract transcript_path and cwd from the JSON\n    49→        let transcript_path = hook_data\n    50→            .get(\"transcript_path\")\n    51→            .and_then(|v| v.as_str())\n    52→            .ok_or_else(|| {\n    53→                GitAiError::PresetError(\"transcript_path not found in hook_input\".to_string())\n    54→            })?;\n    55→\n    56→        let _cwd = hook_data\n    57→            .get(\"cwd\")\n    58→            .and_then(|v| v.as_str())\n    59→            .ok_or_else(|| GitAiError::PresetError(\"cwd not found in hook_input\".to_string()))?;\n    60→\n    61→        // Extract the ID from the filename\n    62→        // Example: /Users/aidancunniffe/.claude/projects/-Users-aidancunniffe-Desktop-ghq/cb947e5b-246e-4253-a953-631f7e464c6b.jsonl\n    63→        let path = Path::new(transcript_path);\n    64→        let filename = path\n    65→            .file_stem()\n    66→            .and_then(|stem| stem.to_str())\n    67→            .ok_or_else(|| {\n    68→                GitAiError::PresetError(\n    69→                    \"Could not extract filename from transcript_path\".to_string(),\n    70→                )\n    71→            })?;\n    72→\n    73→        // Read the file content\n    74→        let jsonl_content =\n    75→            std::fs::read_to_string(transcript_path).map_err(|e| GitAiError::IoError(e))?;\n    76→\n    77→        // Parse into transcript and extract model\n    78→        let (transcript, model) = AiTranscript::from_claude_code_jsonl_with_model(&jsonl_content)\n    79→            .map_err(|e| GitAiError::JsonError(e))?;\n    80→\n    81→        // The filename should be a UUID\n    82→        let agent_id = AgentId {\n    83→            tool: \"claude\".to_string(),\n    84→            id: filename.to_string(),\n    85→            model: model.unwrap_or_else(|| \"unknown\".to_string()),\n    86→        };\n    87→\n    88→        // Extract file_path from tool_input if present\n    89→        let file_path_as_vec = hook_data\n    90→            .get(\"tool_input\")\n    91→            .and_then(|ti| ti.get(\"file_path\"))\n    92→            .and_then(|v| v.as_str())\n    93→            .map(|path| vec![path.to_string()]);\n    94→\n    95→        // Check if this is a PreToolUse event (human checkpoint)\n    96→        let hook_event_name = hook_data.get(\"hook_event_name\").and_then(|v| v.as_str());\n    97→\n    98→        if hook_event_name == Some(\"PreToolUse\") {\n    99→            // Early return for human checkpoint\n   100→            return Ok(AgentRunResult {\n   101→                agent_id,\n   102→                agent_metadata: None,\n   103→                checkpoint_kind: CheckpointKind::Human,\n   104→                transcript: None,\n   105→                repo_working_dir: None,\n   106→                edited_filepaths: None,\n   107→                will_edit_filepaths: file_path_as_vec,\n   108→                dirty_files: None,\n   109→            });\n   110→        }\n   111→\n   112→        Ok(AgentRunResult {\n   113→            agent_id,\n   114→            agent_metadata: None,\n   115→            checkpoint_kind: CheckpointKind::AiAgent,\n   116→            transcript: Some(transcript),\n   117→            // use default.\n   118→            repo_working_dir: None,\n   119→            edited_filepaths: file_path_as_vec,\n   120→            will_edit_filepaths: None,\n   121→            dirty_files: None,\n   122→        })\n   123→    }\n   124→}\n   125→\n   126→// Cursor to checkpoint preset\n   127→pub struct CursorPreset;\n   128→\n   129→impl AgentCheckpointPreset for CursorPreset {\n   130→    fn run(&self, flags: AgentCheckpointFlags) -> Result<AgentRunResult, GitAiError> {\n   131→        // Parse hook_input JSON to extract workspace_roots and conversation_id\n   132→        let hook_input_json = flags.hook_input.ok_or_else(|| {\n   133→            GitAiError::PresetError(\"hook_input is required for Cursor preset\".to_string())\n   134→        })?;\n   135→\n   136→        let hook_data: serde_json::Value = serde_json::from_str(&hook_input_json)\n   137→            .map_err(|e| GitAiError::PresetError(format!(\"Invalid JSON in hook_input: {}\", e)))?;\n   138→\n   139→        // Extract conversation_id and workspace_roots from the JSON\n   140→        let conversation_id = hook_data\n   141→            .get(\"conversation_id\")\n   142→            .and_then(|v| v.as_str())\n   143→            .ok_or_else(|| {\n   144→                GitAiError::PresetError(\"conversation_id not found in hook_input\".to_string())\n   145→            })?\n   146→            .to_string();\n   147→\n   148→        let workspace_roots = hook_data\n   149→            .get(\"workspace_roots\")\n   150→            .and_then(|v| v.as_array())\n   151→            .ok_or_else(|| {\n   152→                GitAiError::PresetError(\"workspace_roots not found in hook_input\".to_string())\n   153→            })?\n   154→            .iter()\n   155→            .filter_map(|v| v.as_str().map(|s| s.to_string()))\n   156→            .collect::<Vec<String>>();\n   157→\n   158→        let hook_event_name = hook_data\n   159→            .get(\"hook_event_name\")\n   160→            .and_then(|v| v.as_str())\n   161→            .ok_or_else(|| {\n   162→                GitAiError::PresetError(\"hook_event_name not found in hook_input\".to_string())\n   163→            })?\n   164→            .to_string();\n   165→\n   166→        // Validate hook_event_name\n   167→        if hook_event_name != \"beforeSubmitPrompt\" && hook_event_name != \"afterFileEdit\" {\n   168→            return Err(GitAiError::PresetError(format!(\n   169→                \"Invalid hook_event_name: {}. Expected 'beforeSubmitPrompt' or 'afterFileEdit'\",\n   170→                hook_event_name\n   171→            )));\n   172→        }\n   173→\n   174→        let repo_working_dir = workspace_roots.first().cloned().ok_or_else(|| {\n   175→            GitAiError::PresetError(\"No workspace root found in hook_input\".to_string())\n   176→        })?;\n   177→\n   178→        if hook_event_name == \"beforeSubmitPrompt\" {\n   179→            // early return, we're just adding a human checkpoint.\n   180→            return Ok(AgentRunResult {\n   181→                agent_id: AgentId {\n   182→                    tool: \"cursor\".to_string(),\n   183→                    id: conversation_id.clone(),\n   184→                    model: \"unknown\".to_string(),\n   185→                },\n   186→                agent_metadata: None,\n   187→                checkpoint_kind: CheckpointKind::Human,\n   188→                transcript: None,\n   189→                repo_working_dir: Some(repo_working_dir),\n   190→                edited_filepaths: None,\n   191→                will_edit_filepaths: None,\n   192→                dirty_files: None,\n   193→            });\n   194→        }\n   195→\n   196→        // Locate Cursor storage\n   197→        let global_db = Self::cursor_global_database_path()?;\n   198→        if !global_db.exists() {\n   199→            return Err(GitAiError::PresetError(format!(\n   200→                \"Cursor global state database not found at {:?}. \\\n   201→                Make sure Cursor is installed and has been used at least once. \\\n   202→                Expected location: {:?}\",\n   203→                global_db,\n   204→                global_db,\n   205→            )));\n   206→        }\n   207→\n   208→        // Fetch the composer data and extract transcript + model + edited filepaths\n   209→        let (transcript, model) = match Self::fetch_composer_payload(&global_db, &conversation_id)\n   210→        {\n   211→            Ok(payload) => Self::transcript_data_from_composer_payload(\n   212→                &payload,\n   213→                &global_db,\n   214→                &conversation_id,\n   215→            )?\n   216→            .unwrap_or_else(|| {\n   217→                // Return empty transcript as default\n   218→                // There's a race condition causing new threads to sometimes not show up.\n   219→                // We refresh and grab all the messages in post-commit so we're ok with returning an empty (placeholder) transcript here and not throwing\n   220→                eprintln!(\n   221→                    \"[Warning] Could not extract transcript from Cursor composer. Retrying at commit.\"\n   222→                );\n   223→                (AiTranscript::new(), \"unknown\".to_string())\n   224→            }),\n   225→            Err(GitAiError::PresetError(msg))\n   226→                if msg == \"No conversation data found in database\" =>\n   227→            {\n   228→                // Gracefully continue when the conversation hasn't been written yet due to Cursor race conditions\n   229→                eprintln!(\n   230→                    \"[Warning] No conversation data found in Cursor DB for this thread. Proceeding and will re-sync at commit.\"\n   231→                );\n   232→                (AiTranscript::new(), \"unknown\".to_string())\n   233→            }\n   234→            Err(e) => return Err(e),\n   235→        };\n   236→\n   237→        // Extract edited filepaths\n   238→        let mut edited_filepaths: Option<Vec<String>> = None;\n   239→        let file_path = hook_data\n   240→            .get(\"file_path\")\n   241→            .and_then(|v| v.as_str())\n   242→            .unwrap_or(\"\");\n   243→        if !file_path.is_empty() {\n   244→            edited_filepaths = Some(vec![file_path.to_string()]);\n   245→        }\n   246→\n   247→        let agent_id = AgentId {\n   248→            tool: \"cursor\".to_string(),\n   249→            id: conversation_id,\n   250→            model,\n   251→        };\n   252→\n   253→        Ok(AgentRunResult {\n   254→            agent_id,\n   255→            agent_metadata: None,\n   256→            checkpoint_kind: CheckpointKind::AiAgent,\n   257→            transcript: Some(transcript),\n   258→            repo_working_dir: Some(repo_working_dir),\n   259→            edited_filepaths,\n   260→            will_edit_filepaths: None,\n   261→            dirty_files: None,\n   262→        })\n   263→    }\n   264→}\n   265→\n   266→impl CursorPreset {\n   267→    /// Fetch the latest version of a Cursor conversation from the database\n   268→    pub fn fetch_latest_cursor_conversation(\n   269→        conversation_id: &str,\n   270→    ) -> Result<Option<(AiTranscript, String)>, GitAiError> {\n   271→        let global_db = Self::cursor_global_database_path()?;\n   272→        if !global_db.exists() {\n   273→            return Ok(None);\n   274→        }\n   275→\n   276→        // Fetch composer payload\n   277→        let composer_payload = Self::fetch_composer_payload(&global_db, conversation_id)?;\n   278→\n   279→        // Extract transcript and model\n   280→        let transcript_data = Self::transcript_data_from_composer_payload(\n   281→            &composer_payload,\n   282→            &global_db,\n   283→            conversation_id,\n   284→        )?;\n   285→\n   286→        Ok(transcript_data)\n   287→    }\n   288→\n   289→    // Get the Cursor database path\n   290→    fn cursor_global_database_path() -> Result<PathBuf, GitAiError> {\n   291→        if let Ok(global_db_path) = std::env::var(\"GIT_AI_CURSOR_GLOBAL_DB_PATH\") {\n   292→            return Ok(PathBuf::from(global_db_path));\n   293→        }\n   294→        let user_dir = Self::cursor_user_dir()?;\n   295→        let global_db = user_dir.join(\"globalStorage\").join(\"state.vscdb\");\n   296→        Ok(global_db)\n   297→    }\n   298→\n   299→    fn cursor_user_dir() -> Result<PathBuf, GitAiError> {\n   300→        #[cfg(target_os = \"windows\")]\n   301→        {\n   302→            // Windows: %APPDATA%\\Cursor\\User\n   303→            let appdata = env::var(\"APPDATA\")\n   304→                .map_err(|e| GitAiError::Generic(format!(\"APPDATA not set: {}\", e)))?;\n   305→            Ok(Path::new(&appdata).join(\"Cursor\").join(\"User\"))\n   306→        }\n   307→\n   308→        #[cfg(target_os = \"macos\")]\n   309→        {\n   310→            // macOS: ~/Library/Application Support/Cursor/User\n   311→            let home = env::var(\"HOME\")\n   312→                .map_err(|e| GitAiError::Generic(format!(\"HOME not set: {}\", e)))?;\n   313→            Ok(Path::new(&home)\n   314→                .join(\"Library\")\n   315→                .join(\"Application Support\")\n   316→                .join(\"Cursor\")\n   317→                .join(\"User\"))\n   318→        }\n   319→\n   320→        #[cfg(not(any(target_os = \"windows\", target_os = \"macos\")))]\n   321→        {\n   322→            Err(GitAiError::PresetError(\n   323→                \"Cursor is only supported on Windows and macOS platforms\".to_string(),\n   324→            ))\n   325→        }\n   326→    }\n   327→\n   328→    fn open_sqlite_readonly(path: &Path) -> Result<Connection, GitAiError> {\n   329→        Connection::open_with_flags(path, OpenFlags::SQLITE_OPEN_READ_ONLY)\n   330→            .map_err(|e| GitAiError::Generic(format!(\"Failed to open {:?}: {}\", path, e)))\n   331→    }\n   332→\n   333→    pub fn fetch_composer_payload(\n   334→        global_db_path: &Path,\n   335→        composer_id: &str,\n   336→    ) -> Result<serde_json::Value, GitAiError> {\n   337→        let conn = Self::open_sqlite_readonly(global_db_path)?;\n   338→\n   339→        // Look for the composer data in cursorDiskKV\n   340→        let key_pattern = format!(\"composerData:{}\", composer_id);\n   341→        let mut stmt = conn\n   342→            .prepare(\"SELECT value FROM cursorDiskKV WHERE key = ?\")\n   343→            .map_err(|e| GitAiError::Generic(format!(\"Query failed: {}\", e)))?;\n   344→\n   345→        let mut rows = stmt\n   346→            .query([&key_pattern])\n   347→            .map_err(|e| GitAiError::Generic(format!(\"Query failed: {}\", e)))?;\n   348→\n   349→        if let Ok(Some(row)) = rows.next() {\n   350→            let value_text: String = row\n   351→                .get(0)\n   352→                .map_err(|e| GitAiError::Generic(format!(\"Failed to read value: {}\", e)))?;\n   353→\n   354→            let data = serde_json::from_str::<serde_json::Value>(&value_text)\n   355→                .map_err(|e| GitAiError::Generic(format!(\"Failed to parse JSON: {}\", e)))?;\n   356→\n   357→            return Ok(data);\n   358→        }\n   359→\n   360→        Err(GitAiError::PresetError(\n   361→            \"No conversation data found in database\".to_string(),\n   362→        ))\n   363→    }\n   364→\n   365→    pub fn transcript_data_from_composer_payload(\n   366→        data: &serde_json::Value,\n   367→        global_db_path: &Path,\n   368→        composer_id: &str,\n   369→    ) -> Result<Option<(AiTranscript, String)>, GitAiError> {\n   370→        // Only support fullConversationHeadersOnly (bubbles format) - the current Cursor format\n   371→        // All conversations since April 2025 use this format exclusively\n   372→        let conv = data\n   373→            .get(\"fullConversationHeadersOnly\")\n   374→            .and_then(|v| v.as_array())\n   375→            .ok_or_else(|| {\n   376→                GitAiError::PresetError(\n   377→                    \"Conversation uses unsupported legacy format. Only conversations created after April 2025 are supported.\".to_string()\n   378→                )\n   379→            })?;\n   380→\n   381→        let mut transcript = AiTranscript::new();\n   382→        let mut model = None;\n   383→\n   384→        for header in conv.iter() {\n   385→            if let Some(bubble_id) = header.get(\"bubbleId\").and_then(|v| v.as_str()) {\n   386→                if let Ok(Some(bubble_content)) =\n   387→                    Self::fetch_bubble_content_from_db(global_db_path, composer_id, bubble_id)\n   388→                {\n   389→                    // Get bubble created at (ISO 8601 UTC string)\n   390→                    let bubble_created_at = bubble_content\n   391→                        .get(\"createdAt\")\n   392→                        .and_then(|v| v.as_str())\n   393→                        .map(|s| s.to_string());\n   394→\n   395→                    // Extract model from bubble (first value wins)\n   396→                    if model.is_none() {\n   397→                        if let Some(model_info) = bubble_content.get(\"modelInfo\") {\n   398→                            if let Some(model_name) =\n   399→                                model_info.get(\"modelName\").and_then(|v| v.as_str())\n   400→                            {\n   401→                                model = Some(model_name.to_string());\n   402→                            }\n   403→                        }\n   404→                    }\n   405→\n   406→                    // Extract text from bubble\n   407→                    if let Some(text) = bubble_content.get(\"text\").and_then(|v| v.as_str()) {\n   408→                        let trimmed = text.trim();\n   409→                        if !trimmed.is_empty() {\n   410→                            let role = header.get(\"type\").and_then(|v| v.as_i64()).unwrap_or(0);\n   411→                            if role == 1 {\n   412→                                transcript.add_message(Message::user(\n   413→                                    trimmed.to_string(),\n   414→                                    bubble_created_at.clone(),\n   415→                                ));\n   416→                            } else {\n   417→                                transcript.add_message(Message::assistant(\n   418→                                    trimmed.to_string(),\n   419→                                    bubble_created_at.clone(),\n   420→                                ));\n   421→                            }\n   422→                        }\n   423→                    }\n   424→\n   425→                    // Handle tool calls and edits\n   426→                    if let Some(tool_former_data) = bubble_content.get(\"toolFormerData\") {\n   427→                        let tool_name = tool_former_data\n   428→                            .get(\"name\")\n   429→                            .and_then(|v| v.as_str())\n   430→                            .unwrap_or(\"unknown\");\n   431→                        let raw_args_str = tool_former_data\n   432→                            .get(\"rawArgs\")\n   433→                            .and_then(|v| v.as_str())\n   434→                            .unwrap_or(\"{}\");\n   435→                        let raw_args_json = serde_json::from_str::<serde_json::Value>(raw_args_str)\n   436→                            .unwrap_or(serde_json::Value::Null);\n   437→                        match tool_name {\n   438→                            \"edit_file\" => {\n   439→                                let target_file =\n   440→                                    raw_args_json.get(\"target_file\").and_then(|v| v.as_str());\n   441→                                transcript.add_message(Message::tool_use(\n   442→                                    tool_name.to_string(),\n   443→                                    // Explicitly clear out everything other than target_file (renamed to file_path for consistency in git-ai) (too much data in rawArgs)\n   444→                                    serde_json::json!({ \"file_path\": target_file.unwrap_or(\"\") }),\n   445→                                ));\n   446→                            }\n   447→                            \"apply_patch\"\n   448→                            | \"edit_file_v2_apply_patch\"\n   449→                            | \"search_replace\"\n   450→                            | \"edit_file_v2_search_replace\"\n   451→                            | \"write\"\n   452→                            | \"MultiEdit\" => {\n   453→                                let file_path =\n   454→                                    raw_args_json.get(\"file_path\").and_then(|v| v.as_str());\n   455→                                transcript.add_message(Message::tool_use(\n   456→                                    tool_name.to_string(),\n   457→                                    // Explicitly clear out everything other than file_path (too much data in rawArgs)\n   458→                                    serde_json::json!({ \"file_path\": file_path.unwrap_or(\"\") }),\n   459→                                ));\n   460→                            }\n   461→                            \"codebase_search\" | \"grep\" | \"read_file\" | \"web_search\"\n   462→                            | \"run_terminal_cmd\" | \"glob_file_search\" | \"todo_write\"\n   463→                            | \"file_search\" | \"grep_search\" | \"list_dir\" | \"ripgrep\" => {\n   464→                                transcript.add_message(Message::tool_use(\n   465→                                    tool_name.to_string(),\n   466→                                    raw_args_json,\n   467→                                ));\n   468→                            }\n   469→                            _ => {}\n   470→                        }\n   471→                    }\n   472→                }\n   473→            }\n   474→        }\n   475→\n   476→        if !transcript.messages.is_empty() {\n   477→            Ok(Some((transcript, model.unwrap_or(\"unknown\".to_string()))))\n   478→        } else {\n   479→            Ok(None)\n   480→        }\n   481→    }\n   482→\n   483→    pub fn fetch_bubble_content_from_db(\n   484→        global_db_path: &Path,\n   485→        composer_id: &str,\n   486→        bubble_id: &str,\n   487→    ) -> Result<Option<serde_json::Value>, GitAiError> {\n   488→        let conn = Self::open_sqlite_readonly(global_db_path)?;\n   489→\n   490→        // Look for bubble data in cursorDiskKV with pattern bubbleId:composerId:bubbleId\n   491→        let bubble_pattern = format!(\"bubbleId:{}:{}\", composer_id, bubble_id);\n   492→        let mut stmt = conn\n   493→            .prepare(\"SELECT value FROM cursorDiskKV WHERE key = ?\")\n   494→            .map_err(|e| GitAiError::Generic(format!(\"Query failed: {}\", e)))?;\n   495→\n   496→        let mut rows = stmt\n   497→            .query([&bubble_pattern])\n   498→            .map_err(|e| GitAiError::Generic(format!(\"Query failed: {}\", e)))?;\n   499→\n   500→        if let Ok(Some(row)) = rows.next() {\n   501→            let value_text: String = row\n   502→                .get(0)\n   503→                .map_err(|e| GitAiError::Generic(format!(\"Failed to read value: {}\", e)))?;\n   504→\n   505→            let data = serde_json::from_str::<serde_json::Value>(&value_text)\n   506→                .map_err(|e| GitAiError::Generic(format!(\"Failed to parse JSON: {}\", e)))?;\n   507→\n   508→            return Ok(Some(data));\n   509→        }\n   510→\n   511→        Ok(None)\n   512→    }\n   513→}\n   514→\n   515→pub struct GithubCopilotPreset;\n   516→\n   517→impl AgentCheckpointPreset for GithubCopilotPreset {\n   518→    fn run(&self, flags: AgentCheckpointFlags) -> Result<AgentRunResult, GitAiError> {\n   519→        // Parse hook_input JSON to extract chat session information\n   520→        let hook_input_json = flags.hook_input.ok_or_else(|| {\n   521→            GitAiError::PresetError(\"hook_input is required for GitHub Copilot preset\".to_string())\n   522→        })?;\n   523→\n   524→        let hook_data: serde_json::Value = serde_json::from_str(&hook_input_json)\n   525→            .map_err(|e| GitAiError::PresetError(format!(\"Invalid JSON in hook_input: {}\", e)))?;\n   526→\n   527→        let chat_session_path = hook_data\n   528→            .get(\"chatSessionPath\")\n   529→            .and_then(|v| v.as_str())\n   530→            .ok_or_else(|| {\n   531→                GitAiError::PresetError(\"chatSessionPath not found in hook_input\".to_string())\n   532→            })?;\n   533→        \n   534→        let agent_metadata = HashMap::from([\n   535→            (\"chat_session_path\".to_string(), chat_session_path.to_string()),\n   536→        ]);\n   537→\n   538→        // Accept either chatSessionId (old) or sessionId (from VS Code extension)\n   539→        let chat_session_id = hook_data\n   540→            .get(\"chatSessionId\")\n   541→            .and_then(|v| v.as_str())\n   542→            .or_else(|| hook_data.get(\"sessionId\").and_then(|v| v.as_str()))\n   543→            .unwrap_or(\"unknown\")\n   544→            .to_string();\n   545→\n   546→        // Extract dirtyFiles if available\n   547→        let dirty_files = hook_data\n   548→            .get(\"dirtyFiles\")\n   549→            .and_then(|v| v.as_object())\n   550→            .map(|obj| {\n   551→                obj.iter()\n   552→                    .filter_map(|(key, value)| {\n   553→                        value\n   554→                            .as_str()\n   555→                            .map(|content| (key.clone(), content.to_string()))\n   556→                    })\n   557→                    .collect::<HashMap<String, String>>()\n   558→            });\n   559→\n   560→        // Required working directory provided by the extension\n   561→        let repo_working_dir: String = hook_data\n   562→            .get(\"workspaceFolder\")\n   563→            .and_then(|v| v.as_str())\n   564→            .ok_or_else(|| {\n   565→                GitAiError::PresetError(\n   566→                    \"workspaceFolder not found in hook_input for GitHub Copilot preset\".to_string(),\n   567→                )\n   568→            })?\n   569→            .to_string();\n   570→\n   571→        // Read the Copilot chat session JSON (ignore errors)\n   572→        let (transcript, detected_model, edited_filepaths) =\n   573→            GithubCopilotPreset::transcript_and_model_from_copilot_session_json(chat_session_path)\n   574→                .map(|(t, m, f)| (Some(t), m, f))\n   575→                .unwrap_or_else(|e| {\n   576→                    // TODO Log error to sentry (JSON exists but invalid)\n   577→                    eprintln!(\n   578→                        \"[Warning] Failed to parse GitHub Copilot chat session JSON from {} (will update transcript at commit): {}\",\n   579→                        chat_session_path,\n   580→                        e\n   581→                    );\n   582→                    (None, None, None)\n   583→                });\n   584→\n   585→        let agent_id = AgentId {\n   586→            tool: \"github-copilot\".to_string(),\n   587→            id: chat_session_id,\n   588→            model: detected_model.unwrap_or_else(|| \"unknown\".to_string()),\n   589→        };\n   590→\n   591→        Ok(AgentRunResult {\n   592→            agent_id,\n   593→            agent_metadata: Some(agent_metadata),\n   594→            checkpoint_kind: CheckpointKind::AiAgent,\n   595→            transcript,\n   596→            repo_working_dir: Some(repo_working_dir),\n   597→            edited_filepaths,\n   598→            will_edit_filepaths: None,\n   599→            dirty_files,\n   600→        })\n   601→    }\n   602→}\n   603→\n   604→impl GithubCopilotPreset {\n   605→    /// Translate a GitHub Copilot chat session JSON file into an AiTranscript, optional model, and edited filepaths.\n   606→    /// Returns an empty transcript if running in Codespaces or Remote Containers.\n   607→    pub fn transcript_and_model_from_copilot_session_json(\n   608→        session_json_path: &str,\n   609→    ) -> Result<(AiTranscript, Option<String>, Option<Vec<String>>), GitAiError> {\n   610→        // Check if running in Codespaces or Remote Containers - if so, return empty transcript\n   611→        let is_codespaces = env::var(\"CODESPACES\").ok().as_deref() == Some(\"true\");\n   612→        let is_remote_containers = env::var(\"REMOTE_CONTAINERS\").ok().as_deref() == Some(\"true\");\n   613→\n   614→        if is_codespaces || is_remote_containers {\n   615→            return Ok((AiTranscript::new(), None, Some(Vec::new())));\n   616→        }\n   617→\n   618→        // Read the session JSON file\n   619→        let session_json_str = std::fs::read_to_string(session_json_path)\n   620→            .map_err(|e| GitAiError::IoError(e))?;\n   621→\n   622→        let session_json: serde_json::Value =\n   623→            serde_json::from_str(&session_json_str).map_err(|e| GitAiError::JsonError(e))?;\n   624→\n   625→        // Extract the requests array which represents the conversation from start to finish\n   626→        let requests = session_json\n   627→            .get(\"requests\")\n   628→            .and_then(|v| v.as_array())\n   629→            .ok_or_else(|| {\n   630→                GitAiError::PresetError(\n   631→                    \"requests array not found in Copilot chat session\".to_string(),\n   632→                )\n   633→            })?;\n   634→\n   635→        let mut transcript = AiTranscript::new();\n   636→        let mut detected_model: Option<String> = None;\n   637→        let mut edited_filepaths: Vec<String> = Vec::new();\n   638→\n   639→        for request in requests {\n   640→            // Parse the human timestamp once per request (unix ms and RFC3339)\n   641→            let user_ts_ms = request.get(\"timestamp\").and_then(|v| v.as_i64());\n   642→            let user_ts_rfc3339 = user_ts_ms.and_then(|ms| {\n   643→                Utc.timestamp_millis_opt(ms)\n   644→                    .single()\n   645→                    .map(|dt| dt.to_rfc3339())\n   646→            });\n   647→\n   648→            // Add the human's message\n   649→            if let Some(user_text) = request\n   650→                .get(\"message\")\n   651→                .and_then(|m| m.get(\"text\"))\n   652→                .and_then(|v| v.as_str())\n   653→            {\n   654→                let trimmed = user_text.trim();\n   655→                if !trimmed.is_empty() {\n   656→                    transcript.add_message(Message::User {\n   657→                        text: trimmed.to_string(),\n   658→                        timestamp: user_ts_rfc3339.clone(),\n   659→                    });\n   660→                }\n   661→            }\n   662→\n   663→            // Process the agent's response items: tool invocations, edits, and text\n   664→            if let Some(response_items) = request.get(\"response\").and_then(|v| v.as_array()) {\n   665→                let mut assistant_text_accumulator = String::new();\n   666→\n   667→                for item in response_items {\n   668→                    // Capture tool invocations and other structured actions as tool_use\n   669→                    if let Some(kind) = item.get(\"kind\").and_then(|v| v.as_str()) {\n   670→                        match kind {\n   671→                            // Primary tool invocation entries\n   672→                            \"toolInvocationSerialized\" => {\n   673→                                let tool_name = item\n   674→                                    .get(\"toolId\")\n   675→                                    .and_then(|v| v.as_str())\n   676→                                    .unwrap_or(\"tool\");\n   677→\n   678→                                // Normalize invocationMessage to a string\n   679→                                let inv_msg = item.get(\"invocationMessage\").and_then(|im| {\n   680→                                    if let Some(s) = im.as_str() {\n   681→                                        Some(s.to_string())\n   682→                                    } else if im.is_object() {\n   683→                                        im.get(\"value\")\n   684→                                            .and_then(|v| v.as_str())\n   685→                                            .map(|s| s.to_string())\n   686→                                    } else {\n   687→                                        None\n   688→                                    }\n   689→                                });\n   690→\n   691→                                if let Some(msg) = inv_msg {\n   692→                                    transcript.add_message(Message::tool_use(\n   693→                                        tool_name.to_string(),\n   694→                                        serde_json::Value::String(msg),\n   695→                                    ));\n   696→                                }\n   697→                            }\n   698→                            // Other structured response elements worth capturing\n   699→                            \"textEditGroup\" => {\n   700→                                // Extract file path from textEditGroup\n   701→                                if let Some(uri_obj) = item.get(\"uri\") {\n   702→                                    let path_opt = uri_obj\n   703→                                        .get(\"fsPath\")\n   704→                                        .and_then(|v| v.as_str())\n   705→                                        .map(|s| s.to_string())\n   706→                                        .or_else(|| {\n   707→                                            uri_obj\n   708→                                                .get(\"path\")\n   709→                                                .and_then(|v| v.as_str())\n   710→                                                .map(|s| s.to_string())\n   711→                                        });\n   712→                                    if let Some(p) = path_opt {\n   713→                                        if !edited_filepaths.contains(&p) {\n   714→                                            edited_filepaths.push(p);\n   715→                                        }\n   716→                                    }\n   717→                                }\n   718→                                transcript\n   719→                                    .add_message(Message::tool_use(kind.to_string(), item.clone()));\n   720→                            }\n   721→                            \"prepareToolInvocation\" => {\n   722→                                transcript\n   723→                                    .add_message(Message::tool_use(kind.to_string(), item.clone()));\n   724→                            }\n   725→                            // codeblockUri should contribute a visible mention like @path, not a tool_use\n   726→                            \"codeblockUri\" => {\n   727→                                let path_opt = item\n   728→                                    .get(\"uri\")\n   729→                                    .and_then(|u| {\n   730→                                        u.get(\"fsPath\")\n   731→                                            .and_then(|v| v.as_str())\n   732→                                            .map(|s| s.to_string())\n   733→                                            .or_else(|| {\n   734→                                                u.get(\"path\")\n   735→                                                    .and_then(|v| v.as_str())\n   736→                                                    .map(|s| s.to_string())\n   737→                                            })\n   738→                                    })\n   739→                                    .or_else(|| {\n   740→                                        item.get(\"fsPath\")\n   741→                                            .and_then(|v| v.as_str())\n   742→                                            .map(|s| s.to_string())\n   743→                                    })\n   744→                                    .or_else(|| {\n   745→                                        item.get(\"path\")\n   746→                                            .and_then(|v| v.as_str())\n   747→                                            .map(|s| s.to_string())\n   748→                                    });\n   749→                                if let Some(p) = path_opt {\n   750→                                    let mention = format!(\"@{}\", p);\n   751→                                    if !assistant_text_accumulator.is_empty() {\n   752→                                        assistant_text_accumulator.push(' ');\n   753→                                    }\n   754→                                    assistant_text_accumulator.push_str(&mention);\n   755→                                }\n   756→                            }\n   757→                            // inlineReference should contribute a visible mention like @path, not a tool_use\n   758→                            \"inlineReference\" => {\n   759→                                let path_opt = item.get(\"inlineReference\").and_then(|ir| {\n   760→                                    // Try nested uri.fsPath or uri.path\n   761→                                    ir.get(\"uri\")\n   762→                                        .and_then(|u| u.get(\"fsPath\"))\n   763→                                        .and_then(|v| v.as_str())\n   764→                                        .map(|s| s.to_string())\n   765→                                        .or_else(|| {\n   766→                                            ir.get(\"uri\")\n   767→                                                .and_then(|u| u.get(\"path\"))\n   768→                                                .and_then(|v| v.as_str())\n   769→                                                .map(|s| s.to_string())\n   770→                                        })\n   771→                                        // Or top-level fsPath / path on inlineReference\n   772→                                        .or_else(|| {\n   773→                                            ir.get(\"fsPath\")\n   774→                                                .and_then(|v| v.as_str())\n   775→                                                .map(|s| s.to_string())\n   776→                                        })\n   777→                                        .or_else(|| {\n   778→                                            ir.get(\"path\")\n   779→                                                .and_then(|v| v.as_str())\n   780→                                                .map(|s| s.to_string())\n   781→                                        })\n   782→                                });\n   783→                                if let Some(p) = path_opt {\n   784→                                    let mention = format!(\"@{}\", p);\n   785→                                    if !assistant_text_accumulator.is_empty() {\n   786→                                        assistant_text_accumulator.push(' ');\n   787→                                    }\n   788→                                    assistant_text_accumulator.push_str(&mention);\n   789→                                }\n   790→                            }\n   791→                            _ => {}\n   792→                        }\n   793→                    }\n   794→\n   795→                    // Accumulate visible assistant text snippets\n   796→                    if let Some(val) = item.get(\"value\").and_then(|v| v.as_str()) {\n   797→                        let t = val.trim();\n   798→                        if !t.is_empty() {\n   799→                            if !assistant_text_accumulator.is_empty() {\n   800→                                assistant_text_accumulator.push(' ');\n   801→                            }\n   802→                            assistant_text_accumulator.push_str(t);\n   803→                        }\n   804→                    }\n   805→                }\n   806→\n   807→                if !assistant_text_accumulator.trim().is_empty() {\n   808→                    // Set assistant timestamp to user_ts + totalElapsed if available\n   809→                    let assistant_ts = request\n   810→                        .get(\"result\")\n   811→                        .and_then(|r| r.get(\"timings\"))\n   812→                        .and_then(|t| t.get(\"totalElapsed\"))\n   813→                        .and_then(|v| v.as_i64())\n   814→                        .and_then(|elapsed| user_ts_ms.map(|ums| ums + elapsed))\n   815→                        .and_then(|ms| {\n   816→                            Utc.timestamp_millis_opt(ms)\n   817→                                .single()\n   818→                                .map(|dt| dt.to_rfc3339())\n   819→                        });\n   820→\n   821→                    transcript.add_message(Message::Assistant {\n   822→                        text: assistant_text_accumulator.trim().to_string(),\n   823→                        timestamp: assistant_ts,\n   824→                    });\n   825→                }\n   826→            }\n   827→\n   828→            // Detect model from request metadata if not yet set (uses first modelId seen)\n   829→            if detected_model.is_none() {\n   830→                if let Some(model_id) = request.get(\"modelId\").and_then(|v| v.as_str()) {\n   831→                    detected_model = Some(model_id.to_string());\n   832→                }\n   833→            }\n   834→        }\n   835→\n   836→        Ok((transcript, detected_model, Some(edited_filepaths)))\n   837→    }\n   838→}\n   839→\n   840→pub struct AiTabPreset;\n   841→\n   842→#[derive(Debug, Deserialize)]\n   843→struct AiTabHookInput {\n   844→    hook_event_name: String,\n   845→    tool: String,\n   846→    model: String,\n   847→    repo_working_dir: Option<String>,\n   848→    will_edit_filepaths: Option<Vec<String>>,\n   849→    edited_filepaths: Option<Vec<String>>,\n   850→    completion_id: Option<String>,\n   851→    dirty_files: Option<HashMap<String, String>>,\n   852→}\n   853→\n   854→impl AgentCheckpointPreset for AiTabPreset {\n   855→    fn run(&self, flags: AgentCheckpointFlags) -> Result<AgentRunResult, GitAiError> {\n   856→        let hook_input_json = flags.hook_input.ok_or_else(|| {\n   857→            GitAiError::PresetError(\"hook_input is required for ai_tab preset\".to_string())\n   858→        })?;\n   859→\n   860→        let hook_input: AiTabHookInput = serde_json::from_str(&hook_input_json)\n   861→            .map_err(|e| GitAiError::PresetError(format!(\"Invalid JSON in hook_input: {}\", e)))?;\n   862→\n   863→        let AiTabHookInput {\n   864→            hook_event_name,\n   865→            tool,\n   866→            model,\n   867→            repo_working_dir,\n   868→            will_edit_filepaths,\n   869→            edited_filepaths,\n   870→            completion_id,\n   871→            dirty_files,\n   872→        } = hook_input;\n   873→\n   874→        if hook_event_name != \"before_edit\" && hook_event_name != \"after_edit\" {\n   875→            return Err(GitAiError::PresetError(format!(\n   876→                \"Unsupported hook_event_name '{}' for ai_tab preset (expected 'before_edit' or 'after_edit')\",\n   877→                hook_event_name\n   878→            )));\n   879→        }\n   880→\n   881→        let tool = tool.trim().to_string();\n   882→        if tool.is_empty() {\n   883→            return Err(GitAiError::PresetError(\n   884→                \"tool must be a non-empty string for ai_tab preset\".to_string(),\n   885→            ));\n   886→        }\n   887→\n   888→        let model = model.trim().to_string();\n   889→        if model.is_empty() {\n   890→            return Err(GitAiError::PresetError(\n   891→                \"model must be a non-empty string for ai_tab preset\".to_string(),\n   892→            ));\n   893→        }\n   894→\n   895→        let repo_working_dir = repo_working_dir\n   896→            .map(|s| s.trim().to_string())\n   897→            .filter(|s| !s.is_empty());\n   898→\n   899→        let agent_id = AgentId {\n   900→            tool,\n   901→            id: format!(\"ai_tab-{}\", completion_id.unwrap_or_else(|| Utc::now().timestamp_millis().to_string())),\n   902→            model,\n   903→        };\n   904→\n   905→        if hook_event_name == \"before_edit\" {\n   906→            return Ok(AgentRunResult {\n   907→                agent_id,\n   908→                agent_metadata: None,\n   909→                checkpoint_kind: CheckpointKind::Human,\n   910→                transcript: None,\n   911→                repo_working_dir,\n   912→                edited_filepaths: None,\n   913→                will_edit_filepaths,\n   914→                dirty_files,\n   915→            });\n   916→        }\n   917→\n   918→        Ok(AgentRunResult {\n   919→            agent_id,\n   920→            agent_metadata: None,\n   921→            checkpoint_kind: CheckpointKind::AiTab,\n   922→            transcript: None,\n   923→            repo_working_dir,\n   924→            edited_filepaths,\n   925→            will_edit_filepaths: None,\n   926→            dirty_files,\n   927→        })\n   928→    }\n   929→}\n   930→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-12-03T21:13:34.081Z"
        },
        {
          "type": "assistant",
          "text": "I'll update the cursor agent preset to use the model from the hook input data instead of pulling it from the sqlite database.",
          "timestamp": "2025-12-03T21:13:47.573Z"
        },
        {
          "type": "tool_use",
          "name": "Edit",
          "input": {
            "file_path": "/Users/svarlamov/projects/git-ai/src/commands/checkpoint_agent/agent_presets.rs",
            "new_string": "        let hook_event_name = hook_data\n            .get(\"hook_event_name\")\n            .and_then(|v| v.as_str())\n            .ok_or_else(|| {\n                GitAiError::PresetError(\"hook_event_name not found in hook_input\".to_string())\n            })?\n            .to_string();\n\n        // Extract model from hook input (Cursor provides this directly)\n        let model = hook_data\n            .get(\"model\")\n            .and_then(|v| v.as_str())\n            .map(|s| s.to_string())\n            .unwrap_or_else(|| \"unknown\".to_string());\n\n        // Validate hook_event_name\n        if hook_event_name != \"beforeSubmitPrompt\" && hook_event_name != \"afterFileEdit\" {\n            return Err(GitAiError::PresetError(format!(\n                \"Invalid hook_event_name: {}. Expected 'beforeSubmitPrompt' or 'afterFileEdit'\",\n                hook_event_name\n            )));\n        }",
            "old_string": "        let hook_event_name = hook_data\n            .get(\"hook_event_name\")\n            .and_then(|v| v.as_str())\n            .ok_or_else(|| {\n                GitAiError::PresetError(\"hook_event_name not found in hook_input\".to_string())\n            })?\n            .to_string();\n\n        // Validate hook_event_name\n        if hook_event_name != \"beforeSubmitPrompt\" && hook_event_name != \"afterFileEdit\" {\n            return Err(GitAiError::PresetError(format!(\n                \"Invalid hook_event_name: {}. Expected 'beforeSubmitPrompt' or 'afterFileEdit'\",\n                hook_event_name\n            )));\n        }"
          },
          "timestamp": "2025-12-03T21:13:53.484Z"
        }
      ],
      "total_additions": 13,
      "total_deletions": 6,
      "accepted_lines": 10,
      "overriden_lines": 0
    }
  }
}
