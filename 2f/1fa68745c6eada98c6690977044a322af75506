tests/realistic_complex_edits.rs
  730aa62 1-1210
---
{
  "schema_version": "authorship/3.0.0",
  "git_ai_version": "development:1.0.22",
  "base_commit_sha": "2f1fa68745c6eada98c6690977044a322af75506",
  "prompts": {
    "730aa62": {
      "agent_id": {
        "tool": "claude",
        "id": "77500146-e32d-42fd-9085-1c03f067e1d2",
        "model": "claude-sonnet-4-5-20250929"
      },
      "human_author": "Sasha Varlamov <sasha@sashavarlamov.com>",
      "messages": [
        {
          "type": "assistant",
          "text": "I'll add comprehensive tests with realistic code files and complex edit sequences. Let me examine the test repo helpers first to understand how to use `write_and_checkpoint_with_contents`.",
          "timestamp": "2025-11-22T16:02:37.806Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/Users/svarlamov/projects/git-ai/tests/repos/test_file.rs"
          },
          "timestamp": "2025-11-22T16:02:38.405Z"
        },
        {
          "type": "tool_use",
          "name": "Read",
          "input": {
            "file_path": "/Users/svarlamov/projects/git-ai/tests/repos/test_repo.rs"
          },
          "timestamp": "2025-11-22T16:02:38.855Z"
        },
        {
          "type": "user",
          "text": "     1→use git_ai::authorship::authorship_log_serialization::AuthorshipLog;\n     2→use git_ai::authorship::stats::CommitStats;\n     3→use git_ai::git::repo_storage::PersistedWorkingLog;\n     4→use git_ai::git::repository as GitAiRepository;\n     5→use git2::Repository;\n     6→use insta::assert_debug_snapshot;\n     7→use rand::Rng;\n     8→use std::fs;\n     9→use std::path::PathBuf;\n    10→use std::process::Command;\n    11→use std::sync::OnceLock;\n    12→\n    13→use super::test_file::TestFile;\n    14→\n    15→#[derive(Clone, Debug)]\n    16→pub struct TestRepo {\n    17→    path: PathBuf,\n    18→}\n    19→\n    20→impl TestRepo {\n    21→    pub fn new() -> Self {\n    22→        let mut rng = rand::thread_rng();\n    23→        let n: u64 = rng.gen_range(0..10000000000);\n    24→        let base = std::env::temp_dir();\n    25→        let path = base.join(n.to_string());\n    26→        let repo = Repository::init(&path).expect(\"failed to initialize git2 repository\");\n    27→        let mut config = Repository::config(&repo).expect(\"failed to initialize git2 repository\");\n    28→        config\n    29→            .set_str(\"user.name\", \"Test User\")\n    30→            .expect(\"failed to initialize git2 repository\");\n    31→        config\n    32→            .set_str(\"user.email\", \"test@example.com\")\n    33→            .expect(\"failed to initialize git2 repository\");\n    34→\n    35→        Self { path }\n    36→    }\n    37→\n    38→    pub fn path(&self) -> &PathBuf {\n    39→        &self.path\n    40→    }\n    41→\n    42→    pub fn canonical_path(&self) -> PathBuf {\n    43→        self.path\n    44→            .canonicalize()\n    45→            .expect(\"failed to canonicalize test repo path\")\n    46→    }\n    47→\n    48→    pub fn stats(&self) -> Result<CommitStats, String> {\n    49→        let mut stats = self.git_ai(&[\"stats\", \"--json\"]).unwrap();\n    50→        stats = stats.split(\"}}}\").next().unwrap().to_string() + \"}}}\";\n    51→        let stats: CommitStats = serde_json::from_str(&stats).unwrap();\n    52→        Ok(stats)\n    53→    }\n    54→\n    55→    pub fn current_branch(&self) -> String {\n    56→        self.git(&[\"branch\", \"--show-current\"])\n    57→            .unwrap()\n    58→            .trim()\n    59→            .to_string()\n    60→    }\n    61→\n    62→    pub fn git_ai(&self, args: &[&str]) -> Result<String, String> {\n    63→        return self.git_ai_with_env(args, &[]);\n    64→    }\n    65→\n    66→    pub fn git(&self, args: &[&str]) -> Result<String, String> {\n    67→        return self.git_with_env(args, &[]);\n    68→    }\n    69→\n    70→    pub fn git_with_env(&self, args: &[&str], envs: &[(&str, &str)]) -> Result<String, String> {\n    71→        let binary_path = get_binary_path();\n    72→\n    73→        let mut full_args = vec![\"-C\", self.path.to_str().unwrap()];\n    74→        full_args.extend(args);\n    75→\n    76→        let mut command = Command::new(binary_path);\n    77→        command.args(&full_args).env(\"GIT_AI\", \"git\");\n    78→\n    79→        // Add custom environment variables\n    80→        for (key, value) in envs {\n    81→            command.env(key, value);\n    82→        }\n    83→\n    84→        let output = command.output().expect(&format!(\n    85→            \"Failed to execute git command with env: {:?}\",\n    86→            args\n    87→        ));\n    88→\n    89→        let stdout = String::from_utf8_lossy(&output.stdout).to_string();\n    90→        let stderr = String::from_utf8_lossy(&output.stderr).to_string();\n    91→\n    92→        if output.status.success() {\n    93→            // Combine stdout and stderr since git often writes to stderr\n    94→            let combined = if stdout.is_empty() {\n    95→                stderr\n    96→            } else if stderr.is_empty() {\n    97→                stdout\n    98→            } else {\n    99→                format!(\"{}{}\", stdout, stderr)\n   100→            };\n   101→            Ok(combined)\n   102→        } else {\n   103→            Err(stderr)\n   104→        }\n   105→    }\n   106→\n   107→    pub fn git_ai_with_env(&self, args: &[&str], envs: &[(&str, &str)]) -> Result<String, String> {\n   108→        let binary_path = get_binary_path();\n   109→\n   110→        let mut command = Command::new(binary_path);\n   111→        command.args(args).current_dir(&self.path);\n   112→\n   113→        // Add custom environment variables\n   114→        for (key, value) in envs {\n   115→            command.env(key, value);\n   116→        }\n   117→\n   118→        let output = command\n   119→            .output()\n   120→            .expect(&format!(\"Failed to execute git-ai command: {:?}\", args));\n   121→\n   122→        let stdout = String::from_utf8_lossy(&output.stdout).to_string();\n   123→        let stderr = String::from_utf8_lossy(&output.stderr).to_string();\n   124→\n   125→        if output.status.success() {\n   126→            // Combine stdout and stderr since git-ai often writes to stderr\n   127→            let combined = if stdout.is_empty() {\n   128→                stderr\n   129→            } else if stderr.is_empty() {\n   130→                stdout\n   131→            } else {\n   132→                format!(\"{}{}\", stdout, stderr)\n   133→            };\n   134→            Ok(combined)\n   135→        } else {\n   136→            Err(stderr)\n   137→        }\n   138→    }\n   139→\n   140→    pub fn filename(&self, filename: &str) -> TestFile {\n   141→        let file_path = self.path.join(filename);\n   142→\n   143→        // If file exists, populate from existing file with blame\n   144→        if file_path.exists() {\n   145→            TestFile::from_existing_file(file_path, self)\n   146→        } else {\n   147→            // New file, start with empty lines\n   148→            TestFile::new_with_filename(file_path, vec![], self)\n   149→        }\n   150→    }\n   151→\n   152→    pub fn current_working_logs(&self) -> PersistedWorkingLog {\n   153→        let repo = GitAiRepository::find_repository_in_path(self.path.to_str().unwrap())\n   154→            .expect(\"Failed to find repository\");\n   155→\n   156→        // Get the current HEAD commit SHA, or use \"initial\" for empty repos\n   157→        let commit_sha = repo\n   158→            .head()\n   159→            .ok()\n   160→            .and_then(|head| head.target().ok())\n   161→            .unwrap_or_else(|| \"initial\".to_string());\n   162→\n   163→        // Get the working log for the current HEAD commit\n   164→        repo.storage.working_log_for_base_commit(&commit_sha)\n   165→    }\n   166→\n   167→    pub fn commit(&self, message: &str) -> Result<NewCommit, String> {\n   168→        return self.commit_with_env(message, &[]);\n   169→    }\n   170→\n   171→    pub fn stage_all_and_commit(&self, message: &str) -> Result<NewCommit, String> {\n   172→        self.git(&[\"add\", \"-A\"]).expect(\"add --all should succeed\");\n   173→        self.commit(message)\n   174→    }\n   175→\n   176→    pub fn commit_with_env(&self, message: &str, envs: &[(&str, &str)]) -> Result<NewCommit, String> {\n   177→        let output = self.git_with_env(&[\"commit\", \"-m\", message], envs);\n   178→\n   179→        // println!(\"commit output: {:?}\", output);\n   180→        if output.is_ok() {\n   181→            let combined = output.unwrap();\n   182→\n   183→            // Get the repository and HEAD commit SHA\n   184→            let repo = GitAiRepository::find_repository_in_path(self.path.to_str().unwrap())\n   185→                .map_err(|e| format!(\"Failed to find repository: {}\", e))?;\n   186→\n   187→            let head_commit = repo\n   188→                .head()\n   189→                .map_err(|e| format!(\"Failed to get HEAD: {}\", e))?\n   190→                .target()\n   191→                .map_err(|e| format!(\"Failed to get HEAD target: {}\", e))?;\n   192→\n   193→            // Get the authorship log for the new commit\n   194→            let authorship_log = match git_ai::git::refs::show_authorship_note(&repo, &head_commit)\n   195→            {\n   196→                Some(content) => AuthorshipLog::deserialize_from_string(&content)\n   197→                    .map_err(|e| format!(\"Failed to parse authorship log: {}\", e))?,\n   198→                None => {\n   199→                    return Err(\"No authorship log found for the new commit\".to_string());\n   200→                }\n   201→            };\n   202→\n   203→            Ok(NewCommit {\n   204→                commit_sha: head_commit,\n   205→                authorship_log,\n   206→                stdout: combined,\n   207→            })\n   208→        } else {\n   209→            Err(output.unwrap_err())\n   210→        }\n   211→    }\n   212→\n   213→    pub fn read_file(&self, filename: &str) -> Option<String> {\n   214→        let file_path = self.path.join(filename);\n   215→        fs::read_to_string(&file_path).ok()\n   216→    }\n   217→}\n   218→\n   219→impl Drop for TestRepo {\n   220→    fn drop(&mut self) {\n   221→        fs::remove_dir_all(self.path.clone()).expect(\"failed to remove test repo\");\n   222→    }\n   223→}\n   224→\n   225→#[derive(Debug)]\n   226→pub struct NewCommit {\n   227→    pub authorship_log: AuthorshipLog,\n   228→    pub stdout: String,\n   229→    pub commit_sha: String,\n   230→}\n   231→\n   232→impl NewCommit {\n   233→    pub fn assert_authorship_snapshot(&self) {\n   234→        assert_debug_snapshot!(self.authorship_log);\n   235→    }\n   236→    pub fn print_authorship(&self) {\n   237→        // Debug method to print authorship log\n   238→        println!(\"{}\", self.authorship_log.serialize_to_string().unwrap());\n   239→    }\n   240→}\n   241→\n   242→static COMPILED_BINARY: OnceLock<PathBuf> = OnceLock::new();\n   243→\n   244→fn compile_binary() -> PathBuf {\n   245→    println!(\"Compiling git-ai binary for tests...\");\n   246→\n   247→    let manifest_dir = env!(\"CARGO_MANIFEST_DIR\");\n   248→    let output = Command::new(\"cargo\")\n   249→        .args(&[\"build\", \"--bin\", \"git-ai\"])\n   250→        .current_dir(manifest_dir)\n   251→        .output()\n   252→        .expect(\"Failed to compile git-ai binary\");\n   253→\n   254→    if !output.status.success() {\n   255→        panic!(\n   256→            \"Failed to compile git-ai:\\nstdout: {}\\nstderr: {}\",\n   257→            String::from_utf8_lossy(&output.stdout),\n   258→            String::from_utf8_lossy(&output.stderr)\n   259→        );\n   260→    }\n   261→\n   262→    let binary_path = PathBuf::from(manifest_dir).join(\"target/debug/git-ai\");\n   263→    binary_path\n   264→}\n   265→\n   266→fn get_binary_path() -> &'static PathBuf {\n   267→    COMPILED_BINARY.get_or_init(compile_binary)\n   268→}\n   269→\n   270→#[cfg(test)]\n   271→mod tests {\n   272→    use super::super::test_file::ExpectedLineExt;\n   273→    use super::TestRepo;\n   274→    use crate::lines;\n   275→\n   276→    #[test]\n   277→    fn test_invoke_git() {\n   278→        let repo = TestRepo::new();\n   279→        let output = repo.git(&[\"status\"]).expect(\"git status should succeed\");\n   280→        println!(\"output: {}\", output);\n   281→        assert!(output.contains(\"On branch\"));\n   282→    }\n   283→\n   284→    #[test]\n   285→    fn test_invoke_git_ai() {\n   286→        let repo = TestRepo::new();\n   287→        let output = repo\n   288→            .git_ai(&[\"version\"])\n   289→            .expect(\"git-ai version should succeed\");\n   290→        assert!(!output.is_empty());\n   291→    }\n   292→\n   293→    // #[test]\n   294→    // fn test_exp() {\n   295→    //     let repo = TestRepo::new();\n   296→\n   297→    //     let mut example_txt = repo.filename(\"example.txt\");\n   298→    //     example_txt.set_contents(vec![\"og\".human(), \"og2\".ai()]);\n   299→\n   300→    //     example_txt.insert_at(\n   301→    //         0,\n   302→    //         lines![\n   303→    //             \"HUMAN\",\n   304→    //             \"HUMAN\".ai(),\n   305→    //             \"HUMAN\",\n   306→    //             \"HUMAN\",\n   307→    //             \"Hello, world!\".ai(),\n   308→    //         ],\n   309→    //     );\n   310→\n   311→    //     example_txt.delete_at(3);\n   312→\n   313→    //     let _commit = repo.stage_all_and_commit(\"mix ai human\").unwrap();\n   314→\n   315→    //     // Assert that blame output matches expected authorship\n   316→    //     example_txt.assert_blame_contents_expected();\n   317→\n   318→    //     example_txt.assert_blame_snapshot();\n   319→\n   320→    //     example_txt.assert_contents_expected();\n   321→    // }\n   322→\n   323→    #[test]\n   324→    fn test_assert_lines_and_blame() {\n   325→        let repo = TestRepo::new();\n   326→\n   327→        let mut example_txt = repo.filename(\"example.txt\");\n   328→\n   329→        // Set up the file with some AI and human lines\n   330→        example_txt.set_contents(lines![\"line 1\", \"line 2\".ai(), \"line 3\", \"line 4\".ai()]);\n   331→\n   332→        repo.stage_all_and_commit(\"test commit\").unwrap();\n   333→\n   334→        // Now assert the exact output using the new syntax\n   335→        example_txt.assert_lines_and_blame(lines![\n   336→            \"line 1\".human(),\n   337→            \"line 2\".ai(),\n   338→            \"line 3\".human(),\n   339→            \"line 4\".ai(),\n   340→        ]);\n   341→    }\n   342→}\n   343→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it looks malicious. If it does, you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer high-level questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-11-22T16:02:38.902Z"
        },
        {
          "type": "user",
          "text": "     1→use std::{fs, path::PathBuf};\n     2→\n     3→use insta::assert_debug_snapshot;\n     4→\n     5→#[derive(Debug, Clone, PartialEq)]\n     6→pub enum AuthorType {\n     7→    Human,\n     8→    Ai,\n     9→}\n    10→\n    11→#[derive(Debug, Clone)]\n    12→pub struct ExpectedLine {\n    13→    pub contents: String,\n    14→    pub author_type: AuthorType,\n    15→}\n    16→\n    17→impl ExpectedLine {\n    18→    fn new(contents: String, author_type: AuthorType) -> Self {\n    19→        if contents.contains('\\n') {\n    20→            panic!(\n    21→                \"fluent test file API does not support strings with new lines (must be a single line): {:?}\",\n    22→                contents\n    23→            );\n    24→        }\n    25→        Self {\n    26→            contents,\n    27→            author_type,\n    28→        }\n    29→    }\n    30→}\n    31→\n    32→/// Trait to add .ai() and .human() methods to string types\n    33→pub trait ExpectedLineExt {\n    34→    fn ai(self) -> ExpectedLine;\n    35→    fn human(self) -> ExpectedLine;\n    36→}\n    37→\n    38→impl ExpectedLineExt for &str {\n    39→    fn ai(self) -> ExpectedLine {\n    40→        ExpectedLine::new(self.to_string(), AuthorType::Ai)\n    41→    }\n    42→\n    43→    fn human(self) -> ExpectedLine {\n    44→        ExpectedLine::new(self.to_string(), AuthorType::Human)\n    45→    }\n    46→}\n    47→\n    48→impl ExpectedLineExt for String {\n    49→    fn ai(self) -> ExpectedLine {\n    50→        ExpectedLine::new(self, AuthorType::Ai)\n    51→    }\n    52→\n    53→    fn human(self) -> ExpectedLine {\n    54→        ExpectedLine::new(self, AuthorType::Human)\n    55→    }\n    56→}\n    57→\n    58→impl ExpectedLineExt for ExpectedLine {\n    59→    fn ai(self) -> ExpectedLine {\n    60→        ExpectedLine::new(self.contents, AuthorType::Ai)\n    61→    }\n    62→\n    63→    fn human(self) -> ExpectedLine {\n    64→        ExpectedLine::new(self.contents, AuthorType::Human)\n    65→    }\n    66→}\n    67→\n    68→/// Default conversion from &str to ExpectedLine (defaults to Human authorship)\n    69→impl From<&str> for ExpectedLine {\n    70→    fn from(s: &str) -> Self {\n    71→        ExpectedLine::new(s.to_string(), AuthorType::Human)\n    72→    }\n    73→}\n    74→\n    75→/// Default conversion from String to ExpectedLine (defaults to Human authorship)\n    76→impl From<String> for ExpectedLine {\n    77→    fn from(s: String) -> Self {\n    78→        ExpectedLine::new(s, AuthorType::Human)\n    79→    }\n    80→}\n    81→\n    82→#[derive(Debug, Clone)]\n    83→pub struct TestFile<'a> {\n    84→    pub lines: Vec<ExpectedLine>,\n    85→    pub file_path: PathBuf,\n    86→    pub repo: &'a super::test_repo::TestRepo,\n    87→}\n    88→\n    89→impl<'a> TestFile<'a> {\n    90→    pub fn new_with_filename(\n    91→        file_path: PathBuf,\n    92→        lines: Vec<ExpectedLine>,\n    93→        repo: &'a super::test_repo::TestRepo,\n    94→    ) -> Self {\n    95→        Self {\n    96→            lines,\n    97→            file_path: file_path,\n    98→            repo,\n    99→        }\n   100→    }\n   101→\n   102→    /// Populate TestFile from an existing file by reading its contents and blame\n   103→    pub fn from_existing_file(file_path: PathBuf, repo: &'a super::test_repo::TestRepo) -> Self {\n   104→        // Check if file exists\n   105→        if !file_path.exists() {\n   106→            return Self {\n   107→                lines: vec![],\n   108→                file_path,\n   109→                repo,\n   110→            };\n   111→        }\n   112→\n   113→        // Read file contents\n   114→        let contents = fs::read_to_string(&file_path).unwrap_or_default();\n   115→        if contents.is_empty() {\n   116→            return Self {\n   117→                lines: vec![],\n   118→                file_path,\n   119→                repo,\n   120→            };\n   121→        }\n   122→\n   123→        // Run blame to get authorship\n   124→        let filename = file_path.to_str().expect(\"valid path\");\n   125→        let blame_result = repo.git_ai(&[\"blame\", filename]);\n   126→\n   127→        let lines = if let Ok(blame_output) = blame_result {\n   128→            // Parse blame output to get authorship for each line\n   129→            let content_lines: Vec<&str> = contents.lines().collect();\n   130→            let blame_lines: Vec<&str> = blame_output\n   131→                .lines()\n   132→                .filter(|line| !line.trim().is_empty())\n   133→                .collect();\n   134→\n   135→            content_lines\n   136→                .iter()\n   137→                .zip(blame_lines.iter())\n   138→                .map(|(content, blame_line)| {\n   139→                    let (author, _) = Self::parse_blame_line_static(blame_line);\n   140→                    let author_type = if Self::is_ai_author_static(&author) {\n   141→                        AuthorType::Ai\n   142→                    } else {\n   143→                        AuthorType::Human\n   144→                    };\n   145→                    ExpectedLine::new(content.to_string(), author_type)\n   146→                })\n   147→                .collect()\n   148→        } else {\n   149→            // No blame available, assume all human\n   150→            contents\n   151→                .lines()\n   152→                .map(|line| ExpectedLine::new(line.to_string(), AuthorType::Human))\n   153→                .collect()\n   154→        };\n   155→\n   156→        Self {\n   157→            lines,\n   158→            file_path,\n   159→            repo,\n   160→        }\n   161→    }\n   162→\n   163→    /// Static version of parse_blame_line for use in from_existing_file\n   164→    fn parse_blame_line_static(line: &str) -> (String, String) {\n   165→        if let Some(start_paren) = line.find('(') {\n   166→            if let Some(end_paren) = line.find(')') {\n   167→                let author_section = &line[start_paren + 1..end_paren];\n   168→                let content = line[end_paren + 1..].trim();\n   169→\n   170→                // Extract author name (everything before the date)\n   171→                let parts: Vec<&str> = author_section.trim().split_whitespace().collect();\n   172→                let mut author_parts = Vec::new();\n   173→                for part in parts {\n   174→                    // Stop when we hit what looks like a date (starts with digit)\n   175→                    if part.chars().next().unwrap_or('a').is_ascii_digit() {\n   176→                        break;\n   177→                    }\n   178→                    author_parts.push(part);\n   179→                }\n   180→                let author = author_parts.join(\" \");\n   181→\n   182→                return (author, content.to_string());\n   183→            }\n   184→        }\n   185→        (\"unknown\".to_string(), line.to_string())\n   186→    }\n   187→\n   188→    /// Static version of is_ai_author for use in from_existing_file\n   189→    fn is_ai_author_static(author: &str) -> bool {\n   190→        let author_lower = author.to_lowercase();\n   191→        author_lower.contains(\"mock_ai\")\n   192→            || author_lower.contains(\"mock_ai\")\n   193→            || author_lower.contains(\"claude\")\n   194→            || author_lower.contains(\"gpt\")\n   195→            || author_lower.contains(\"copilot\")\n   196→            || author_lower.contains(\"cursor\")\n   197→    }\n   198→\n   199→    pub fn stage(&self) {\n   200→        self.repo\n   201→            .git(&[\"add\", self.file_path.to_str().expect(\"valid path\")])\n   202→            .expect(\"add file should succeed\");\n   203→    }\n   204→\n   205→    pub fn assert_contents_expected(&self) {\n   206→        let contents = fs::read_to_string(&self.file_path).unwrap();\n   207→        assert_eq!(\n   208→            contents,\n   209→            self.contents(),\n   210→            \"Unexpected contents in file: {}\",\n   211→            self.file_path.display(),\n   212→        );\n   213→    }\n   214→\n   215→    pub fn assert_blame_snapshot(&self) {\n   216→        let filename = self.file_path.to_str().expect(\"valid path\");\n   217→        let blame_output = self\n   218→            .repo\n   219→            .git_ai(&[\"blame\", filename])\n   220→            .expect(\"git-ai blame should succeed\");\n   221→\n   222→        let formatted = self.format_blame_for_snapshot(&blame_output);\n   223→        assert_debug_snapshot!(formatted);\n   224→    }\n   225→\n   226→    pub fn assert_lines_and_blame<T: Into<ExpectedLine>>(&mut self, lines: Vec<T>) {\n   227→        let expected_lines: Vec<ExpectedLine> = lines.into_iter().map(|l| l.into()).collect();\n   228→\n   229→        // Get blame output\n   230→        let filename = self.file_path.to_str().expect(\"valid path\");\n   231→        let blame_output = self\n   232→            .repo\n   233→            .git_ai(&[\"blame\", filename])\n   234→            .expect(\"git-ai blame should succeed\");\n   235→\n   236→        // Parse the blame output to get (author, content) for each line\n   237→        let actual_lines: Vec<(String, String)> = blame_output\n   238→            .lines()\n   239→            .filter(|line| !line.trim().is_empty())\n   240→            .map(|line| self.parse_blame_line(line))\n   241→            .collect();\n   242→\n   243→        // Compare line counts\n   244→        assert_eq!(\n   245→            actual_lines.len(),\n   246→            expected_lines.len(),\n   247→            \"Number of lines in blame output ({}) doesn't match expected ({})\\nBlame output:\\n{}\",\n   248→            actual_lines.len(),\n   249→            expected_lines.len(),\n   250→            blame_output\n   251→        );\n   252→\n   253→        // Compare each line's content and authorship\n   254→        for (i, ((actual_author, actual_content), expected_line)) in\n   255→            actual_lines.iter().zip(&expected_lines).enumerate()\n   256→        {\n   257→            let line_num = i + 1;\n   258→\n   259→            // Check line content\n   260→            assert_eq!(\n   261→                actual_content.trim(),\n   262→                expected_line.contents.trim(),\n   263→                \"Line {}: Content mismatch\\nExpected: {:?}\\nActual: {:?}\\nFull blame output:\\n{}\",\n   264→                line_num,\n   265→                expected_line.contents,\n   266→                actual_content,\n   267→                blame_output\n   268→            );\n   269→\n   270→            // Check authorship\n   271→            match &expected_line.author_type {\n   272→                AuthorType::Ai => {\n   273→                    assert!(\n   274→                        self.is_ai_author(actual_author),\n   275→                        \"Line {}: Expected AI author but got '{}'\\nExpected: {:?}\\nActual content: {:?}\\nFull blame output:\\n{}\",\n   276→                        line_num,\n   277→                        actual_author,\n   278→                        expected_line,\n   279→                        actual_content,\n   280→                        blame_output\n   281→                    );\n   282→                }\n   283→                AuthorType::Human => {\n   284→                    assert!(\n   285→                        !self.is_ai_author(actual_author),\n   286→                        \"Line {}: Expected Human author but got AI author '{}'\\nExpected: {:?}\\nActual content: {:?}\\nFull blame output:\\n{}\",\n   287→                        line_num,\n   288→                        actual_author,\n   289→                        expected_line,\n   290→                        actual_content,\n   291→                        blame_output\n   292→                    );\n   293→                }\n   294→            }\n   295→        }\n   296→    }\n   297→\n   298→    /// Assert only committed lines (filters out uncommitted lines)\n   299→    /// Useful for partial staging tests where some lines aren't committed yet\n   300→    pub fn assert_committed_lines<T: Into<ExpectedLine>>(&mut self, lines: Vec<T>) {\n   301→        let expected_lines: Vec<ExpectedLine> = lines.into_iter().map(|l| l.into()).collect();\n   302→\n   303→        // Get blame output\n   304→        let filename = self.file_path.to_str().expect(\"valid path\");\n   305→        let blame_output = self\n   306→            .repo\n   307→            .git_ai(&[\"blame\", filename])\n   308→            .expect(\"git-ai blame should succeed\");\n   309→\n   310→        // Parse the blame output and filter out uncommitted lines\n   311→        let committed_lines: Vec<(String, String)> = blame_output\n   312→            .lines()\n   313→            .filter(|line| !line.trim().is_empty())\n   314→            .map(|line| self.parse_blame_line(line))\n   315→            .filter(|(author, _)| author != \"Not Committed Yet\")\n   316→            .collect();\n   317→\n   318→        // Compare line counts\n   319→        assert_eq!(\n   320→            committed_lines.len(),\n   321→            expected_lines.len(),\n   322→            \"Number of committed lines ({}) doesn't match expected ({})\\nBlame output:\\n{}\",\n   323→            committed_lines.len(),\n   324→            expected_lines.len(),\n   325→            blame_output\n   326→        );\n   327→\n   328→        // Compare each line's content and authorship\n   329→        for (i, ((actual_author, actual_content), expected_line)) in\n   330→            committed_lines.iter().zip(&expected_lines).enumerate()\n   331→        {\n   332→            let line_num = i + 1;\n   333→\n   334→            // Check line content\n   335→            assert_eq!(\n   336→                actual_content.trim(),\n   337→                expected_line.contents.trim(),\n   338→                \"Line {}: Content mismatch\\nExpected: {:?}\\nActual: {:?}\\nFull blame output:\\n{}\",\n   339→                line_num,\n   340→                expected_line.contents,\n   341→                actual_content,\n   342→                blame_output\n   343→            );\n   344→\n   345→            // Check authorship\n   346→            match &expected_line.author_type {\n   347→                AuthorType::Ai => {\n   348→                    assert!(\n   349→                        self.is_ai_author(actual_author),\n   350→                        \"Line {}: Expected AI author but got '{}'\\nExpected: {:?}\\nActual content: {:?}\\nFull blame output:\\n{}\",\n   351→                        line_num,\n   352→                        actual_author,\n   353→                        expected_line,\n   354→                        actual_content,\n   355→                        blame_output\n   356→                    );\n   357→                }\n   358→                AuthorType::Human => {\n   359→                    assert!(\n   360→                        !self.is_ai_author(actual_author),\n   361→                        \"Line {}: Expected Human author but got AI author '{}'\\nExpected: {:?}\\nActual content: {:?}\\nFull blame output:\\n{}\",\n   362→                        line_num,\n   363→                        actual_author,\n   364→                        expected_line,\n   365→                        actual_content,\n   366→                        blame_output\n   367→                    );\n   368→                }\n   369→            }\n   370→        }\n   371→    }\n   372→\n   373→    /// Format blame output for readable snapshots\n   374→    /// Format: Name of user\\n\\n$author 1) LINE CONTENTS\\n$author 2) LINE CONTENTS\n   375→    pub fn format_blame_for_snapshot(&self, blame_output: &str) -> String {\n   376→        let mut result = String::new();\n   377→        let mut current_author: Option<String> = None;\n   378→        let mut line_num = 1;\n   379→\n   380→        for line in blame_output.lines() {\n   381→            if line.trim().is_empty() {\n   382→                continue;\n   383→            }\n   384→\n   385→            // Parse the blame line to extract author and content\n   386→            let (author, content) = self.parse_blame_line(line);\n   387→\n   388→            // Add header when author changes\n   389→            if current_author.as_ref() != Some(&author) {\n   390→                if current_author.is_some() {\n   391→                    result.push('\\n');\n   392→                }\n   393→                result.push_str(&format!(\"{}\\n\\n\", author));\n   394→                current_author = Some(author.clone());\n   395→            }\n   396→\n   397→            // Add the line with author prefix and line number\n   398→            result.push_str(&format!(\"{} {}) {}\\n\", author, line_num, content));\n   399→            line_num += 1;\n   400→        }\n   401→\n   402→        result\n   403→    }\n   404→\n   405→    /// Parse a single blame line to extract author and content\n   406→    /// Format: sha (author date line_num) content\n   407→    pub fn parse_blame_line(&self, line: &str) -> (String, String) {\n   408→        if let Some(start_paren) = line.find('(') {\n   409→            if let Some(end_paren) = line.find(')') {\n   410→                let author_section = &line[start_paren + 1..end_paren];\n   411→                let content = line[end_paren + 1..].trim();\n   412→\n   413→                // Extract author name (everything before the date)\n   414→                let parts: Vec<&str> = author_section.trim().split_whitespace().collect();\n   415→                let mut author_parts = Vec::new();\n   416→                for part in parts {\n   417→                    // Stop when we hit what looks like a date (starts with digit)\n   418→                    if part.chars().next().unwrap_or('a').is_ascii_digit() {\n   419→                        break;\n   420→                    }\n   421→                    author_parts.push(part);\n   422→                }\n   423→                let author = author_parts.join(\" \");\n   424→\n   425→                return (author, content.to_string());\n   426→            }\n   427→        }\n   428→        (\"unknown\".to_string(), line.to_string())\n   429→    }\n   430→\n   431→    /// Assert that the file at the given path matches the expected contents and authorship\n   432→    pub fn assert_blame_contents_expected(&self) {\n   433→        // Get blame output\n   434→        let filename = self.file_path.to_str().expect(\"valid path\");\n   435→        let blame_output = self\n   436→            .repo\n   437→            .git_ai(&[\"blame\", filename])\n   438→            .expect(\"git-ai blame should succeed\");\n   439→\n   440→        // println!(\n   441→        //     \"\\n=== Git-AI Blame Output ===\\n{}\\n===========================\\n\",\n   442→        //     blame_output\n   443→        // );\n   444→\n   445→        // Parse the blame output to extract authors for each line\n   446→        let lines_by_author = self.parse_blame_output(&blame_output);\n   447→\n   448→        // Compare with expected authorship\n   449→        assert_eq!(\n   450→            lines_by_author.len(),\n   451→            self.lines.len(),\n   452→            \"Number of lines in blame output ({}) doesn't match expected ({})\",\n   453→            lines_by_author.len(),\n   454→            self.lines.len()\n   455→        );\n   456→\n   457→        for (i, (actual_author, expected_line)) in\n   458→            lines_by_author.iter().zip(&self.lines).enumerate()\n   459→        {\n   460→            let line_num = i + 1;\n   461→            match &expected_line.author_type {\n   462→                AuthorType::Ai => {\n   463→                    assert!(\n   464→                        self.is_ai_author(actual_author),\n   465→                        \"Line {}: Expected AI author but got '{}'. Expected line: {:?}\\n{}\",\n   466→                        line_num,\n   467→                        actual_author,\n   468→                        expected_line,\n   469→                        blame_output\n   470→                    );\n   471→                }\n   472→                AuthorType::Human => {\n   473→                    assert!(\n   474→                        !self.is_ai_author(actual_author),\n   475→                        \"Line {}: Expected Human author but got AI author '{}'. Expected line: {:?}\\n{}\",\n   476→                        line_num,\n   477→                        actual_author,\n   478→                        expected_line,\n   479→                        blame_output\n   480→                    );\n   481→                }\n   482→            }\n   483→        }\n   484→    }\n   485→\n   486→    /// Parse git-ai blame output and extract the author for each line\n   487→    /// Format: sha (author date line_num) content\n   488→    fn parse_blame_output(&self, blame_output: &str) -> Vec<String> {\n   489→        blame_output\n   490→            .lines()\n   491→            .filter(|line| !line.trim().is_empty())\n   492→            .map(|line| {\n   493→                // Find the author between the first '(' and the timestamp\n   494→                if let Some(start_paren) = line.find('(') {\n   495→                    let after_paren = &line[start_paren + 1..];\n   496→                    // Author is everything before the date/timestamp\n   497→                    // Date format is typically \"YYYY-MM-DD\" or similar\n   498→                    // Split by multiple spaces or look for year pattern\n   499→                    let parts: Vec<&str> = after_paren.trim().split_whitespace().collect();\n   500→                    if !parts.is_empty() {\n   501→                        // The author is typically the first part before the date\n   502→                        // Date usually starts with a year (4 digits) or a number\n   503→                        let mut author_parts = Vec::new();\n   504→                        for part in parts {\n   505→                            // Stop when we hit what looks like a date (starts with digit)\n   506→                            if part.chars().next().unwrap_or('a').is_ascii_digit() {\n   507→                                break;\n   508→                            }\n   509→                            author_parts.push(part);\n   510→                        }\n   511→                        return author_parts.join(\" \");\n   512→                    }\n   513→                }\n   514→                \"unknown\".to_string()\n   515→            })\n   516→            .collect()\n   517→    }\n   518→\n   519→    /// Check if an author string indicates AI authorship\n   520→    /// AI authors typically contain keywords like \"mock_ai\", agent names, etc.\n   521→    fn is_ai_author(&self, author: &str) -> bool {\n   522→        let author_lower = author.to_lowercase();\n   523→        author_lower.contains(\"mock_ai\")\n   524→            || author_lower.contains(\"mock_ai\")\n   525→            || author_lower.contains(\"claude\")\n   526→            || author_lower.contains(\"gpt\")\n   527→            || author_lower.contains(\"copilot\")\n   528→            || author_lower.contains(\"cursor\")\n   529→    }\n   530→\n   531→    /// Get lines with a specific author type\n   532→    pub fn lines_by_author(&self, author_type: AuthorType) -> Vec<&ExpectedLine> {\n   533→        self.lines\n   534→            .iter()\n   535→            .filter(|line| line.author_type == author_type)\n   536→            .collect()\n   537→    }\n   538→\n   539→    /// Insert lines at the specified index, mutating the TestFile in place\n   540→    pub fn insert_at<T: Into<ExpectedLine>>(\n   541→        &mut self,\n   542→        starting_index: usize,\n   543→        lines: Vec<T>,\n   544→    ) -> &mut Self {\n   545→        let lines: Vec<ExpectedLine> = lines.into_iter().map(|l| l.into()).collect();\n   546→\n   547→        if lines.len() == 0 {\n   548→            panic!(\"[test internals] must insert > 0 lines\")\n   549→        }\n   550→\n   551→        // Build splits - indices where author type changes\n   552→        let mut splits: Vec<usize> = vec![0]; // Always start from index 0\n   553→        let mut last_author_type = &lines[0].author_type;\n   554→\n   555→        for (i, line) in lines.iter().enumerate().skip(1) {\n   556→            if &line.author_type != last_author_type {\n   557→                splits.push(i);\n   558→                last_author_type = &line.author_type;\n   559→            }\n   560→        }\n   561→\n   562→        // Current working state - start with the current file contents\n   563→        let mut cumulative_offset = 0;\n   564→\n   565→        // Process each chunk of same-author lines\n   566→        for (chunk_idx, &split_start) in splits.iter().enumerate() {\n   567→            // Determine the end of this chunk (exclusive)\n   568→            let split_end = if chunk_idx + 1 < splits.len() {\n   569→                splits[chunk_idx + 1]\n   570→            } else {\n   571→                lines.len()\n   572→            };\n   573→\n   574→            // Get the chunk of lines to insert (all have same author type)\n   575→            let chunk = &lines[split_start..split_end];\n   576→            let author_type = &chunk[0].author_type;\n   577→\n   578→            // Insert this chunk into self.lines at the appropriate position\n   579→            let insert_position = starting_index + cumulative_offset;\n   580→            self.lines\n   581→                .splice(insert_position..insert_position, chunk.iter().cloned());\n   582→\n   583→            // Write the current state to disk and create a checkpoint\n   584→            self.write_and_checkpoint(author_type);\n   585→\n   586→            // Update offset for next insertion (next chunk starts after this one)\n   587→            cumulative_offset += chunk.len();\n   588→        }\n   589→\n   590→        self\n   591→    }\n   592→\n   593→    /// Replace a single line at the specified index, mutating the TestFile in place\n   594→    pub fn replace_at<T: Into<ExpectedLine>>(&mut self, index: usize, line: T) -> &mut Self {\n   595→        let line = line.into();\n   596→        if index < self.lines.len() {\n   597→            self.lines[index] = line.clone();\n   598→        } else {\n   599→            panic!(\n   600→                \"Index {} out of bounds for {} lines\",\n   601→                index,\n   602→                self.lines.len()\n   603→            );\n   604→        }\n   605→\n   606→        // Write the updated content to disk and create a checkpoint\n   607→        self.write_and_checkpoint(&line.author_type);\n   608→\n   609→        self\n   610→    }\n   611→\n   612→    /// Delete a single line at the specified index, mutating the TestFile in place\n   613→    /// Deletions are always attributed to humans\n   614→    pub fn delete_at(&mut self, index: usize) -> &mut Self {\n   615→        if index < self.lines.len() {\n   616→            self.lines.remove(index);\n   617→        } else {\n   618→            panic!(\n   619→                \"Index {} out of bounds for {} lines\",\n   620→                index,\n   621→                self.lines.len()\n   622→            );\n   623→        }\n   624→\n   625→        // Write the updated content to disk and create a checkpoint (deletions are human)\n   626→        self.write_and_checkpoint(&AuthorType::Human);\n   627→\n   628→        self\n   629→    }\n   630→\n   631→    /// Delete a range of lines [start..end), mutating the TestFile in place\n   632→    /// Deletions are always attributed to humans\n   633→    pub fn delete_range(&mut self, start: usize, end: usize) -> &mut Self {\n   634→        if start >= end {\n   635→            panic!(\n   636→                \"[test internals] start index {} must be less than end index {}\",\n   637→                start, end\n   638→            );\n   639→        }\n   640→\n   641→        if end > self.lines.len() {\n   642→            panic!(\n   643→                \"End index {} out of bounds for {} lines\",\n   644→                end,\n   645→                self.lines.len()\n   646→            );\n   647→        }\n   648→\n   649→        self.lines.drain(start..end);\n   650→\n   651→        // Write the updated content to disk and create a checkpoint (deletions are human)\n   652→        self.write_and_checkpoint(&AuthorType::Human);\n   653→\n   654→        self\n   655→    }\n   656→\n   657→    pub fn set_contents<T: Into<ExpectedLine>>(&mut self, lines: Vec<T>) -> &mut Self {\n   658→        let lines: Vec<ExpectedLine> = lines.into_iter().map(|l| l.into()).collect();\n   659→        // stub in AI Lines\n   660→        let line_contents = lines\n   661→            .iter()\n   662→            .map(|s| {\n   663→                if s.author_type == AuthorType::Ai {\n   664→                    return \"||__AI LINE__ PENDING__||\".to_string();\n   665→                } else {\n   666→                    return s.contents.clone();\n   667→                }\n   668→            })\n   669→            .collect::<Vec<String>>()\n   670→            .join(\"\\n\");\n   671→\n   672→        self.write_and_checkpoint_with_contents(&line_contents, &AuthorType::Human);\n   673→\n   674→        let line_contents_with_ai = lines\n   675→            .iter()\n   676→            .map(|s| s.contents.clone())\n   677→            .collect::<Vec<String>>()\n   678→            .join(\"\\n\");\n   679→\n   680→        self.write_and_checkpoint_with_contents(&line_contents_with_ai, &AuthorType::Ai);\n   681→\n   682→        self.lines = lines;\n   683→        self\n   684→    }\n   685→\n   686→    /// Set file contents without staging (but still creates checkpoints for authorship tracking)\n   687→    /// Useful for testing scenarios with precise staging control\n   688→    pub fn set_contents_no_stage<T: Into<ExpectedLine>>(&mut self, lines: Vec<T>) -> &mut Self {\n   689→        let lines: Vec<ExpectedLine> = lines.into_iter().map(|l| l.into()).collect();\n   690→\n   691→        // stub in AI Lines\n   692→        let line_contents = lines\n   693→            .iter()\n   694→            .map(|s| {\n   695→                if s.author_type == AuthorType::Ai {\n   696→                    return \"||__AI LINE__ PENDING__||\".to_string();\n   697→                } else {\n   698→                    return s.contents.clone();\n   699→                }\n   700→            })\n   701→            .collect::<Vec<String>>()\n   702→            .join(\"\\n\");\n   703→\n   704→        self.write_and_checkpoint_no_stage(&line_contents, &AuthorType::Human);\n   705→\n   706→        let line_contents_with_ai = lines\n   707→            .iter()\n   708→            .map(|s| s.contents.clone())\n   709→            .collect::<Vec<String>>()\n   710→            .join(\"\\n\");\n   711→\n   712→        self.write_and_checkpoint_no_stage(&line_contents_with_ai, &AuthorType::Ai);\n   713→\n   714→        self.lines = lines;\n   715→        self\n   716→    }\n   717→\n   718→    pub fn contents(&self) -> String {\n   719→        return self\n   720→            .lines\n   721→            .iter()\n   722→            .map(|s| s.contents.clone())\n   723→            .collect::<Vec<String>>()\n   724→            .join(\"\\n\");\n   725→    }\n   726→\n   727→    fn write_and_checkpoint(&self, author_type: &AuthorType) {\n   728→        let contents = self.contents();\n   729→        fs::write(&self.file_path, contents).unwrap();\n   730→        if author_type == &AuthorType::Ai {\n   731→            self.repo.git_ai(&[\"checkpoint\", \"mock_ai\"]).unwrap();\n   732→        } else {\n   733→            self.repo.git_ai(&[\"checkpoint\"]).unwrap();\n   734→        };\n   735→    }\n   736→\n   737→    fn write_and_checkpoint_with_contents(&self, contents: &str, author_type: &AuthorType) {\n   738→        fs::write(&self.file_path, contents).unwrap();\n   739→\n   740→        // Stage the file first\n   741→        self.repo.git(&[\"add\", \"-A\"]).unwrap();\n   742→\n   743→        let result = if author_type == &AuthorType::Ai {\n   744→            self.repo.git_ai(&[\"checkpoint\", \"mock_ai\"])\n   745→        } else {\n   746→            self.repo.git_ai(&[\"checkpoint\"])\n   747→        };\n   748→\n   749→        // match &result {\n   750→        //     Ok(output) => println!(\"✓ checkpoint succeeded: {:?}\", output),\n   751→        //     Err(error) => println!(\"✗ checkpoint failed: {:?}\", error),\n   752→        // }\n   753→\n   754→        result.unwrap();\n   755→    }\n   756→\n   757→    fn write_and_checkpoint_no_stage(&self, contents: &str, author_type: &AuthorType) {\n   758→        fs::write(&self.file_path, contents).unwrap();\n   759→\n   760→        // Create checkpoint without staging - checkpoints work with unstaged files\n   761→        let result = if author_type == &AuthorType::Ai {\n   762→            self.repo.git_ai(&[\"checkpoint\", \"mock_ai\"])\n   763→        } else {\n   764→            self.repo.git_ai(&[\"checkpoint\"])\n   765→        };\n   766→\n   767→        result.unwrap();\n   768→    }\n   769→}\n   770→\n   771→/// Macro to create a Vec<ExpectedLine> from mixed types\n   772→/// Accepts ExpectedLine or any type convertible to ExpectedLine (e.g., &str, String)\n   773→/// Plain strings default to Human authorship\n   774→#[macro_export]\n   775→macro_rules! lines {\n   776→    ($($line:expr),* $(,)?) => {{\n   777→        {\n   778→            use $crate::repos::test_file::ExpectedLine;\n   779→            let v: Vec<ExpectedLine> = vec![$(Into::into($line)),*];\n   780→            v\n   781→        }\n   782→    }};\n   783→}\n   784→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it looks malicious. If it does, you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer high-level questions about the code behavior.\n</system-reminder>\n",
          "timestamp": "2025-11-22T16:02:39.076Z"
        },
        {
          "type": "assistant",
          "text": "Now I'll add comprehensive tests with realistic code files and complex edit sequences. I'll use `write_and_checkpoint_with_contents` to ensure exact control over content and git alignment.",
          "timestamp": "2025-11-22T16:02:43.711Z"
        },
        {
          "type": "tool_use",
          "name": "Edit",
          "input": {
            "file_path": "/Users/svarlamov/projects/git-ai/tests/simple_additions.rs",
            "new_string": "    assert_eq!(\n        stats[\\\"ai_additions\\\"].as_u64().unwrap(),\n        2,\n        \\\"AI additions should be 2, not 4 (Bug #193)\\\"\n    );\n}\n\n#[test]\nfn test_realistic_refactoring_sequence() {\n    // Test a realistic code refactoring scenario with multiple human and AI edits\n    use std::fs;\n\n    let repo = TestRepo::new();\n    let file_path = repo.path().join(\"calculator.rs\");\n\n    // Initial human-written code\n    fs::write(\n        &file_path,\n        \"pub struct Calculator {\n    value: i32,\n}\n\nimpl Calculator {\n    pub fn new() -> Self {\n        Self { value: 0 }\n    }\n\n    pub fn add(&mut self, n: i32) {\n        self.value += n;\n    }\n}\",\n    )\n    .unwrap();\n\n    repo.git_ai(&[\"checkpoint\"]).unwrap();\n    repo.stage_all_and_commit(\"Initial calculator implementation\")\n        .unwrap();\n\n    // AI adds subtract and multiply methods\n    fs::write(\n        &file_path,\n        \"pub struct Calculator {\n    value: i32,\n}\n\nimpl Calculator {\n    pub fn new() -> Self {\n        Self { value: 0 }\n    }\n\n    pub fn add(&mut self, n: i32) {\n        self.value += n;\n    }\n\n    pub fn subtract(&mut self, n: i32) {\n        self.value -= n;\n    }\n\n    pub fn multiply(&mut self, n: i32) {\n        self.value *= n;\n    }\n}\",\n    )\n    .unwrap();\n\n    repo.git_ai(&[\"checkpoint\", \"mock_ai\", \"calculator.rs\"])\n        .unwrap();\n    repo.stage_all_and_commit(\"AI adds subtract and multiply\")\n        .unwrap();\n\n    // Human refactors to add error handling\n    fs::write(\n        &file_path,\n        \"pub struct Calculator {\n    value: i32,\n}\n\nimpl Calculator {\n    pub fn new() -> Self {\n        Self { value: 0 }\n    }\n\n    pub fn add(&mut self, n: i32) -> Result<(), String> {\n        self.value = self.value.checked_add(n).ok_or(\\\"Overflow\\\")?;\n        Ok(())\n    }\n\n    pub fn subtract(&mut self, n: i32) {\n        self.value -= n;\n    }\n\n    pub fn multiply(&mut self, n: i32) {\n        self.value *= n;\n    }\n}\",\n    )\n    .unwrap();\n\n    repo.git_ai(&[\"checkpoint\"]).unwrap();\n    repo.stage_all_and_commit(\"Human adds overflow check to add\")\n        .unwrap();\n\n    // AI completes the refactoring for other methods\n    fs::write(\n        &file_path,\n        \"pub struct Calculator {\n    value: i32,\n}\n\nimpl Calculator {\n    pub fn new() -> Self {\n        Self { value: 0 }\n    }\n\n    pub fn add(&mut self, n: i32) -> Result<(), String> {\n        self.value = self.value.checked_add(n).ok_or(\\\"Overflow\\\")?;\n        Ok(())\n    }\n\n    pub fn subtract(&mut self, n: i32) -> Result<(), String> {\n        self.value = self.value.checked_sub(n).ok_or(\\\"Underflow\\\")?;\n        Ok(())\n    }\n\n    pub fn multiply(&mut self, n: i32) -> Result<(), String> {\n        self.value = self.value.checked_mul(n).ok_or(\\\"Overflow\\\")?;\n        Ok(())\n    }\n}\",\n    )\n    .unwrap();\n\n    repo.git_ai(&[\"checkpoint\", \"mock_ai\", \"calculator.rs\"])\n        .unwrap();\n    repo.stage_all_and_commit(\"AI adds error handling to other methods\")\n        .unwrap();\n\n    // Verify final attribution\n    let mut file = repo.filename(\"calculator.rs\");\n    file.assert_lines_and_blame(lines![\n        \"pub struct Calculator {\".human(),\n        \"    value: i32,\".human(),\n        \"}\".human(),\n        \"\".human(),\n        \"impl Calculator {\".human(),\n        \"    pub fn new() -> Self {\".human(),\n        \"        Self { value: 0 }\".human(),\n        \"    }\".human(),\n        \"    \".human(),\n        \"    pub fn add(&mut self, n: i32) -> Result<(), String> {\".human(),\n        \"        self.value = self.value.checked_add(n).ok_or(\\\"Overflow\\\")?;\".human(),\n        \"        Ok(())\".human(),\n        \"    }\".human(),\n        \"    \".human(),\n        \"    pub fn subtract(&mut self, n: i32) -> Result<(), String> {\".ai(),\n        \"        self.value = self.value.checked_sub(n).ok_or(\\\"Underflow\\\")?;\".ai(),\n        \"        Ok(())\".ai(),\n        \"    }\".ai(),\n        \"    \".ai(),\n        \"    pub fn multiply(&mut self, n: i32) -> Result<(), String> {\".ai(),\n        \"        self.value = self.value.checked_mul(n).ok_or(\\\"Overflow\\\")?;\".ai(),\n        \"        Ok(())\".ai(),\n        \"    }\".ai(),\n        \"}\".human(),\n    ]);\n}\n\n#[test]\nfn test_realistic_api_endpoint_expansion() {\n    // Test AI expanding an API with multiple endpoints, with human edits in between\n    use std::fs;\n\n    let repo = TestRepo::new();\n    let file_path = repo.path().join(\"handlers.rs\");\n\n    // Human writes initial GET endpoint\n    fs::write(\n        &file_path,\n        \"use axum::{Json, extract::Path};\n\npub async fn get_user(Path(id): Path<u32>) -> Json<User> {\n    let user = fetch_user_from_db(id).await;\n    Json(user)\n}\",\n    )\n    .unwrap();\n\n    repo.git_ai(&[\"checkpoint\"]).unwrap();\n    repo.stage_all_and_commit(\"Add get_user endpoint\")\n        .unwrap();\n\n    // AI adds POST endpoint\n    fs::write(\n        &file_path,\n        \"use axum::{Json, extract::Path};\n\npub async fn get_user(Path(id): Path<u32>) -> Json<User> {\n    let user = fetch_user_from_db(id).await;\n    Json(user)\n}\n\npub async fn create_user(Json(payload): Json<CreateUser>) -> Json<User> {\n    let user = insert_user_to_db(payload).await;\n    Json(user)\n}\",\n    )\n    .unwrap();\n\n    repo.git_ai(&[\"checkpoint\", \"mock_ai\", \"handlers.rs\"])\n        .unwrap();\n    repo.stage_all_and_commit(\"AI adds create_user endpoint\")\n        .unwrap();\n\n    // Human adds validation to create_user\n    fs::write(\n        &file_path,\n        \"use axum::{Json, extract::Path};\n\npub async fn get_user(Path(id): Path<u32>) -> Json<User> {\n    let user = fetch_user_from_db(id).await;\n    Json(user)\n}\n\npub async fn create_user(Json(payload): Json<CreateUser>) -> Result<Json<User>, String> {\n    if payload.username.is_empty() {\n        return Err(\\\"Username cannot be empty\\\".to_string());\n    }\n    let user = insert_user_to_db(payload).await;\n    Ok(Json(user))\n}\",\n    )\n    .unwrap();\n\n    repo.git_ai(&[\"checkpoint\"]).unwrap();\n    repo.stage_all_and_commit(\"Human adds validation\")\n        .unwrap();\n\n    // AI adds UPDATE and DELETE endpoints\n    fs::write(\n        &file_path,\n        \"use axum::{Json, extract::Path};\n\npub async fn get_user(Path(id): Path<u32>) -> Json<User> {\n    let user = fetch_user_from_db(id).await;\n    Json(user)\n}\n\npub async fn create_user(Json(payload): Json<CreateUser>) -> Result<Json<User>, String> {\n    if payload.username.is_empty() {\n        return Err(\\\"Username cannot be empty\\\".to_string());\n    }\n    let user = insert_user_to_db(payload).await;\n    Ok(Json(user))\n}\n\npub async fn update_user(Path(id): Path<u32>, Json(payload): Json<UpdateUser>) -> Json<User> {\n    let user = update_user_in_db(id, payload).await;\n    Json(user)\n}\n\npub async fn delete_user(Path(id): Path<u32>) -> Json<()> {\n    delete_user_from_db(id).await;\n    Json(())\n}\",\n    )\n    .unwrap();\n\n    repo.git_ai(&[\"checkpoint\", \"mock_ai\", \"handlers.rs\"])\n        .unwrap();\n    repo.stage_all_and_commit(\"AI adds update and delete endpoints\")\n        .unwrap();\n\n    // Human refactors error handling across all endpoints\n    fs::write(\n        &file_path,\n        \"use axum::{Json, extract::Path, http::StatusCode};\n\npub async fn get_user(Path(id): Path<u32>) -> Result<Json<User>, StatusCode> {\n    let user = fetch_user_from_db(id).await?;\n    Ok(Json(user))\n}\n\npub async fn create_user(Json(payload): Json<CreateUser>) -> Result<Json<User>, StatusCode> {\n    if payload.username.is_empty() {\n        return Err(StatusCode::BAD_REQUEST);\n    }\n    let user = insert_user_to_db(payload).await?;\n    Ok(Json(user))\n}\n\npub async fn update_user(Path(id): Path<u32>, Json(payload): Json<UpdateUser>) -> Json<User> {\n    let user = update_user_in_db(id, payload).await;\n    Json(user)\n}\n\npub async fn delete_user(Path(id): Path<u32>) -> Json<()> {\n    delete_user_from_db(id).await;\n    Json(())\n}\",\n    )\n    .unwrap();\n\n    repo.git_ai(&[\"checkpoint\"]).unwrap();\n    repo.stage_all_and_commit(\"Human refactors error handling\")\n        .unwrap();\n\n    // Verify attribution aligns with git blame\n    let mut file = repo.filename(\"handlers.rs\");\n    file.assert_lines_and_blame(lines![\n        \"use axum::{Json, extract::Path, http::StatusCode};\".human(),\n        \"\".human(),\n        \"pub async fn get_user(Path(id): Path<u32>) -> Result<Json<User>, StatusCode> {\".human(),\n        \"    let user = fetch_user_from_db(id).await?;\".human(),\n        \"    Ok(Json(user))\".human(),\n        \"}\".human(),\n        \"\".human(),\n        \"pub async fn create_user(Json(payload): Json<CreateUser>) -> Result<Json<User>, StatusCode> {\".human(),\n        \"    if payload.username.is_empty() {\".human(),\n        \"        return Err(StatusCode::BAD_REQUEST);\".human(),\n        \"    }\".human(),\n        \"    let user = insert_user_to_db(payload).await?;\".human(),\n        \"    Ok(Json(user))\".human(),\n        \"}\".human(),\n        \"\".ai(),\n        \"pub async fn update_user(Path(id): Path<u32>, Json(payload): Json<UpdateUser>) -> Json<User> {\".ai(),\n        \"    let user = update_user_in_db(id, payload).await;\".ai(),\n        \"    Json(user)\".ai(),\n        \"}\".ai(),\n        \"\".ai(),\n        \"pub async fn delete_user(Path(id): Path<u32>) -> Json<()> {\".ai(),\n        \"    delete_user_from_db(id).await;\".ai(),\n        \"    Json(())\".ai(),\n        \"}\".ai(),\n    ]);\n}\n\n#[test]\nfn test_realistic_test_file_evolution() {\n    // Test evolution of a test file with AI adding tests and human refactoring\n    use std::fs;\n\n    let repo = TestRepo::new();\n    let file_path = repo.path().join(\"tests.rs\");\n\n    // Human writes initial test\n    fs::write(\n        &file_path,\n        \"#[test]\nfn test_addition() {\n    assert_eq!(2 + 2, 4);\n}\",\n    )\n    .unwrap();\n\n    repo.git_ai(&[\"checkpoint\"]).unwrap();\n    repo.stage_all_and_commit(\"Initial test\").unwrap();\n\n    // AI adds more test cases\n    fs::write(\n        &file_path,\n        \"#[test]\nfn test_addition() {\n    assert_eq!(2 + 2, 4);\n}\n\n#[test]\nfn test_subtraction() {\n    assert_eq!(5 - 3, 2);\n}\n\n#[test]\nfn test_multiplication() {\n    assert_eq!(3 * 4, 12);\n}\",\n    )\n    .unwrap();\n\n    repo.git_ai(&[\"checkpoint\", \"mock_ai\", \"tests.rs\"])\n        .unwrap();\n    repo.stage_all_and_commit(\"AI adds more tests\").unwrap();\n\n    // Human refactors to use test module\n    fs::write(\n        &file_path,\n        \"mod arithmetic_tests {\n    #[test]\n    fn test_addition() {\n        assert_eq!(2 + 2, 4);\n    }\n\n    #[test]\n    fn test_subtraction() {\n        assert_eq!(5 - 3, 2);\n    }\n\n    #[test]\n    fn test_multiplication() {\n        assert_eq!(3 * 4, 12);\n    }\n}\",\n    )\n    .unwrap();\n\n    repo.git_ai(&[\"checkpoint\"]).unwrap();\n    repo.stage_all_and_commit(\"Human adds module wrapper\")\n        .unwrap();\n\n    // AI adds division test\n    fs::write(\n        &file_path,\n        \"mod arithmetic_tests {\n    #[test]\n    fn test_addition() {\n        assert_eq!(2 + 2, 4);\n    }\n\n    #[test]\n    fn test_subtraction() {\n        assert_eq!(5 - 3, 2);\n    }\n\n    #[test]\n    fn test_multiplication() {\n        assert_eq!(3 * 4, 12);\n    }\n\n    #[test]\n    fn test_division() {\n        assert_eq!(12 / 3, 4);\n    }\n}\",\n    )\n    .unwrap();\n\n    repo.git_ai(&[\"checkpoint\", \"mock_ai\", \"tests.rs\"])\n        .unwrap();\n    repo.stage_all_and_commit(\"AI adds division test\").unwrap();\n\n    // Human adds edge case test\n    fs::write(\n        &file_path,\n        \"mod arithmetic_tests {\n    #[test]\n    fn test_addition() {\n        assert_eq!(2 + 2, 4);\n    }\n\n    #[test]\n    fn test_subtraction() {\n        assert_eq!(5 - 3, 2);\n    }\n\n    #[test]\n    fn test_multiplication() {\n        assert_eq!(3 * 4, 12);\n    }\n\n    #[test]\n    fn test_division() {\n        assert_eq!(12 / 3, 4);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_division_by_zero() {\n        let _ = 1 / 0;\n    }\n}\",\n    )\n    .unwrap();\n\n    repo.git_ai(&[\"checkpoint\"]).unwrap();\n    repo.stage_all_and_commit(\"Human adds edge case test\")\n        .unwrap();\n\n    // Verify git alignment\n    let mut file = repo.filename(\"tests.rs\");\n    file.assert_lines_and_blame(lines![\n        \"mod arithmetic_tests {\".human(),\n        \"    #[test]\".human(),\n        \"    fn test_addition() {\".human(),\n        \"        assert_eq!(2 + 2, 4);\".human(),\n        \"    }\".human(),\n        \"\".human(),\n        \"    #[test]\".ai(),\n        \"    fn test_subtraction() {\".ai(),\n        \"        assert_eq!(5 - 3, 2);\".ai(),\n        \"    }\".ai(),\n        \"\".ai(),\n        \"    #[test]\".ai(),\n        \"    fn test_multiplication() {\".ai(),\n        \"        assert_eq!(3 * 4, 12);\".ai(),\n        \"    }\".ai(),\n        \"\".ai(),\n        \"    #[test]\".ai(),\n        \"    fn test_division() {\".ai(),\n        \"        assert_eq!(12 / 3, 4);\".ai(),\n        \"    }\".ai(),\n        \"\".human(),\n        \"    #[test]\".human(),\n        \"    #[should_panic]\".human(),\n        \"    fn test_division_by_zero() {\".human(),\n        \"        let _ = 1 / 0;\".human(),\n        \"    }\".human(),\n        \"}\".human(),\n    ]);\n}\n\n#[test]\nfn test_realistic_config_file_with_comments() {\n    // Test AI and human editing a config file with comments\n    use std::fs;\n\n    let repo = TestRepo::new();\n    let file_path = repo.path().join(\"config.toml\");\n\n    // Human creates initial config\n    fs::write(\n        &file_path,\n        \"[server]\nhost = \\\"localhost\\\"\nport = 8080\",\n    )\n    .unwrap();\n\n    repo.git_ai(&[\"checkpoint\"]).unwrap();\n    repo.stage_all_and_commit(\"Initial config\").unwrap();\n\n    // AI adds database config\n    fs::write(\n        &file_path,\n        \"[server]\nhost = \\\"localhost\\\"\nport = 8080\n\n[database]\nurl = \\\"postgresql://localhost/mydb\\\"\nmax_connections = 10\",\n    )\n    .unwrap();\n\n    repo.git_ai(&[\"checkpoint\", \"mock_ai\", \"config.toml\"])\n        .unwrap();\n    repo.stage_all_and_commit(\"AI adds database config\")\n        .unwrap();\n\n    // Human adds comments and changes port\n    fs::write(\n        &file_path,\n        \"# Server configuration\n[server]\nhost = \\\"localhost\\\"\n# Changed to use port 3000\nport = 3000\n\n[database]\nurl = \\\"postgresql://localhost/mydb\\\"\nmax_connections = 10\",\n    )\n    .unwrap();\n\n    repo.git_ai(&[\"checkpoint\"]).unwrap();\n    repo.stage_all_and_commit(\"Human adds comments and changes port\")\n        .unwrap();\n\n    // AI adds logging config\n    fs::write(\n        &file_path,\n        \"# Server configuration\n[server]\nhost = \\\"localhost\\\"\n# Changed to use port 3000\nport = 3000\n\n[database]\nurl = \\\"postgresql://localhost/mydb\\\"\nmax_connections = 10\n\n[logging]\nlevel = \\\"info\\\"\nformat = \\\"json\\\"\",\n    )\n    .unwrap();\n\n    repo.git_ai(&[\"checkpoint\", \"mock_ai\", \"config.toml\"])\n        .unwrap();\n    repo.stage_all_and_commit(\"AI adds logging config\")\n        .unwrap();\n\n    // Verify alignment with git\n    let mut file = repo.filename(\"config.toml\");\n    file.assert_lines_and_blame(lines![\n        \"# Server configuration\".human(),\n        \"[server]\".human(),\n        \"host = \\\"localhost\\\"\".human(),\n        \"# Changed to use port 3000\".human(),\n        \"port = 3000\".human(),\n        \"\".human(),\n        \"[database]\".ai(),\n        \"url = \\\"postgresql://localhost/mydb\\\"\".ai(),\n        \"max_connections = 10\".ai(),\n        \"\".ai(),\n        \"[logging]\".ai(),\n        \"level = \\\"info\\\"\".ai(),\n        \"format = \\\"json\\\"\".ai(),\n    ]);\n}\n\n#[test]\nfn test_realistic_jsx_component_development() {\n    // Test AI and human building a React component together\n    use std::fs;\n\n    let repo = TestRepo::new();\n    let file_path = repo.path().join(\"Button.jsx\");\n\n    // Human creates basic component\n    fs::write(\n        &file_path,\n        \"export function Button({ children }) {\n  return <button>{children}</button>;\n}\",\n    )\n    .unwrap();\n\n    repo.git_ai(&[\"checkpoint\"]).unwrap();\n    repo.stage_all_and_commit(\"Initial Button component\")\n        .unwrap();\n\n    // AI adds onClick and styling props\n    fs::write(\n        &file_path,\n        \"export function Button({ children, onClick, className }) {\n  return (\n    <button onClick={onClick} className={className}>\n      {children}\n    </button>\n  );\n}\",\n    )\n    .unwrap();\n\n    repo.git_ai(&[\"checkpoint\", \"mock_ai\", \"Button.jsx\"])\n        .unwrap();\n    repo.stage_all_and_commit(\"AI adds onClick and className props\")\n        .unwrap();\n\n    // Human adds variant prop with styles\n    fs::write(\n        &file_path,\n        \"export function Button({ children, onClick, className, variant = 'primary' }) {\n  const baseStyles = 'px-4 py-2 rounded';\n  const variantStyles = variant === 'primary' ? 'bg-blue-500 text-white' : 'bg-gray-200';\n\n  return (\n    <button onClick={onClick} className={`${baseStyles} ${variantStyles} ${className}`}>\n      {children}\n    </button>\n  );\n}\",\n    )\n    .unwrap();\n\n    repo.git_ai(&[\"checkpoint\"]).unwrap();\n    repo.stage_all_and_commit(\"Human adds variant styling\")\n        .unwrap();\n\n    // AI adds disabled state\n    fs::write(\n        &file_path,\n        \"export function Button({ children, onClick, className, variant = 'primary', disabled = false }) {\n  const baseStyles = 'px-4 py-2 rounded';\n  const variantStyles = variant === 'primary' ? 'bg-blue-500 text-white' : 'bg-gray-200';\n  const disabledStyles = disabled ? 'opacity-50 cursor-not-allowed' : '';\n\n  return (\n    <button\n      onClick={disabled ? undefined : onClick}\n      className={`${baseStyles} ${variantStyles} ${disabledStyles} ${className}`}\n      disabled={disabled}\n    >\n      {children}\n    </button>\n  );\n}\",\n    )\n    .unwrap();\n\n    repo.git_ai(&[\"checkpoint\", \"mock_ai\", \"Button.jsx\"])\n        .unwrap();\n    repo.stage_all_and_commit(\"AI adds disabled state\").unwrap();\n\n    // Verify git blame alignment\n    let mut file = repo.filename(\"Button.jsx\");\n    file.assert_lines_and_blame(lines![\n        \"export function Button({ children, onClick, className, variant = 'primary', disabled = false }) {\".ai(),\n        \"  const baseStyles = 'px-4 py-2 rounded';\".human(),\n        \"  const variantStyles = variant === 'primary' ? 'bg-blue-500 text-white' : 'bg-gray-200';\".human(),\n        \"  const disabledStyles = disabled ? 'opacity-50 cursor-not-allowed' : '';\".ai(),\n        \"  \".ai(),\n        \"  return (\".ai(),\n        \"    <button \".ai(),\n        \"      onClick={disabled ? undefined : onClick} \".ai(),\n        \"      className={`${baseStyles} ${variantStyles} ${disabledStyles} ${className}`}\".ai(),\n        \"      disabled={disabled}\".ai(),\n        \"    >\".ai(),\n        \"      {children}\".ai(),\n        \"    </button>\".ai(),\n        \"  );\".ai(),\n        \"}\".ai(),\n    ]);\n}\n\n#[test]\nfn test_realistic_class_with_multiple_methods() {\n    // Test complex class evolution with multiple method additions and modifications\n    use std::fs;\n\n    let repo = TestRepo::new();\n    let file_path = repo.path().join(\"UserManager.ts\");\n\n    // Human creates initial class with one method\n    fs::write(\n        &file_path,\n        \"export class UserManager {\n  private users: Map<string, User> = new Map();\n\n  constructor() {}\n\n  addUser(user: User): void {\n    this.users.set(user.id, user);\n  }\n}\",\n    )\n    .unwrap();\n\n    repo.git_ai(&[\"checkpoint\"]).unwrap();\n    repo.stage_all_and_commit(\"Initial UserManager class\")\n        .unwrap();\n\n    // AI adds getUser and removeUser\n    fs::write(\n        &file_path,\n        \"export class UserManager {\n  private users: Map<string, User> = new Map();\n\n  constructor() {}\n\n  addUser(user: User): void {\n    this.users.set(user.id, user);\n  }\n\n  getUser(id: string): User | undefined {\n    return this.users.get(id);\n  }\n\n  removeUser(id: string): boolean {\n    return this.users.delete(id);\n  }\n}\",\n    )\n    .unwrap();\n\n    repo.git_ai(&[\"checkpoint\", \"mock_ai\", \"UserManager.ts\"])\n        .unwrap();\n    repo.stage_all_and_commit(\"AI adds getUser and removeUser\")\n        .unwrap();\n\n    // Human refactors addUser to validate\n    fs::write(\n        &file_path,\n        \"export class UserManager {\n  private users: Map<string, User> = new Map();\n\n  constructor() {}\n\n  addUser(user: User): void {\n    if (!user.id || !user.email) {\n      throw new Error('Invalid user');\n    }\n    this.users.set(user.id, user);\n  }\n\n  getUser(id: string): User | undefined {\n    return this.users.get(id);\n  }\n\n  removeUser(id: string): boolean {\n    return this.users.delete(id);\n  }\n}\",\n    )\n    .unwrap();\n\n    repo.git_ai(&[\"checkpoint\"]).unwrap();\n    repo.stage_all_and_commit(\"Human adds validation to addUser\")\n        .unwrap();\n\n    // AI adds updateUser method\n    fs::write(\n        &file_path,\n        \"export class UserManager {\n  private users: Map<string, User> = new Map();\n\n  constructor() {}\n\n  addUser(user: User): void {\n    if (!user.id || !user.email) {\n      throw new Error('Invalid user');\n    }\n    this.users.set(user.id, user);\n  }\n\n  getUser(id: string): User | undefined {\n    return this.users.get(id);\n  }\n\n  updateUser(id: string, updates: Partial<User>): User | undefined {\n    const user = this.users.get(id);\n    if (!user) return undefined;\n    const updatedUser = { ...user, ...updates };\n    this.users.set(id, updatedUser);\n    return updatedUser;\n  }\n\n  removeUser(id: string): boolean {\n    return this.users.delete(id);\n  }\n}\",\n    )\n    .unwrap();\n\n    repo.git_ai(&[\"checkpoint\", \"mock_ai\", \"UserManager.ts\"])\n        .unwrap();\n    repo.stage_all_and_commit(\"AI adds updateUser method\")\n        .unwrap();\n\n    // Human adds getAllUsers and count\n    fs::write(\n        &file_path,\n        \"export class UserManager {\n  private users: Map<string, User> = new Map();\n\n  constructor() {}\n\n  addUser(user: User): void {\n    if (!user.id || !user.email) {\n      throw new Error('Invalid user');\n    }\n    this.users.set(user.id, user);\n  }\n\n  getUser(id: string): User | undefined {\n    return this.users.get(id);\n  }\n\n  getAllUsers(): User[] {\n    return Array.from(this.users.values());\n  }\n\n  getUserCount(): number {\n    return this.users.size;\n  }\n\n  updateUser(id: string, updates: Partial<User>): User | undefined {\n    const user = this.users.get(id);\n    if (!user) return undefined;\n    const updatedUser = { ...user, ...updates };\n    this.users.set(id, updatedUser);\n    return updatedUser;\n  }\n\n  removeUser(id: string): boolean {\n    return this.users.delete(id);\n  }\n}\",\n    )\n    .unwrap();\n\n    repo.git_ai(&[\"checkpoint\"]).unwrap();\n    repo.stage_all_and_commit(\"Human adds getAllUsers and getUserCount\")\n        .unwrap();\n\n    // Verify git blame alignment\n    let mut file = repo.filename(\"UserManager.ts\");\n    file.assert_lines_and_blame(lines![\n        \"export class UserManager {\".human(),\n        \"  private users: Map<string, User> = new Map();\".human(),\n        \"\".human(),\n        \"  constructor() {}\".human(),\n        \"\".human(),\n        \"  addUser(user: User): void {\".human(),\n        \"    if (!user.id || !user.email) {\".human(),\n        \"      throw new Error('Invalid user');\".human(),\n        \"    }\".human(),\n        \"    this.users.set(user.id, user);\".human(),\n        \"  }\".human(),\n        \"\".human(),\n        \"  getUser(id: string): User | undefined {\".ai(),\n        \"    return this.users.get(id);\".ai(),\n        \"  }\".ai(),\n        \"\".human(),\n        \"  getAllUsers(): User[] {\".human(),\n        \"    return Array.from(this.users.values());\".human(),\n        \"  }\".human(),\n        \"\".human(),\n        \"  getUserCount(): number {\".human(),\n        \"    return this.users.size;\".human(),\n        \"  }\".human(),\n        \"\".ai(),\n        \"  updateUser(id: string, updates: Partial<User>): User | undefined {\".ai(),\n        \"    const user = this.users.get(id);\".ai(),\n        \"    if (!user) return undefined;\".ai(),\n        \"    const updatedUser = { ...user, ...updates };\".ai(),\n        \"    this.users.set(id, updatedUser);\".ai(),\n        \"    return updatedUser;\".ai(),\n        \"  }\".ai(),\n        \"\".ai(),\n        \"  removeUser(id: string): boolean {\".ai(),\n        \"    return this.users.delete(id);\".ai(),\n        \"  }\".ai(),\n        \"}\".human(),\n    ]);\n}",
            "old_string": "    assert_eq!(\n        stats[\\\"ai_additions\\\"].as_u64().unwrap(),\n        2,\n        \\\"AI additions should be 2, not 4 (Bug #193)\\\"\n    );\n}"
          },
          "timestamp": "2025-11-22T16:03:59.926Z"
        },
        {
          "type": "user",
          "text": "<tool_use_error>File has not been read yet. Read it first before writing to it.</tool_use_error>",
          "timestamp": "2025-11-22T16:03:59.994Z"
        },
        {
          "type": "assistant",
          "text": "Let me read the file first:",
          "timestamp": "2025-11-22T16:04:03.469Z"
        },
        {
          "type": "tool_use",
          "name": "Edit",
          "input": {
            "file_path": "/Users/svarlamov/projects/git-ai/tests/simple_additions.rs",
            "new_string": "    assert_eq!(\n        stats[\"ai_additions\"].as_u64().unwrap(),\n        2,\n        \"AI additions should be 2, not 4 (Bug #193)\"\n    );\n}\n\n#[test]\nfn test_realistic_refactoring_sequence() {\n    // Test a realistic code refactoring scenario with multiple human and AI edits\n    use std::fs;\n\n    let repo = TestRepo::new();\n    let file_path = repo.path().join(\"calculator.rs\");\n\n    // Initial human-written code\n    fs::write(\n        &file_path,\n        \"pub struct Calculator {\n    value: i32,\n}\n\nimpl Calculator {\n    pub fn new() -> Self {\n        Self { value: 0 }\n    }\n\n    pub fn add(&mut self, n: i32) {\n        self.value += n;\n    }\n}\",\n    )\n    .unwrap();\n\n    repo.git_ai(&[\"checkpoint\"]).unwrap();\n    repo.stage_all_and_commit(\"Initial calculator implementation\")\n        .unwrap();\n\n    // AI adds subtract and multiply methods\n    fs::write(\n        &file_path,\n        \"pub struct Calculator {\n    value: i32,\n}\n\nimpl Calculator {\n    pub fn new() -> Self {\n        Self { value: 0 }\n    }\n\n    pub fn add(&mut self, n: i32) {\n        self.value += n;\n    }\n\n    pub fn subtract(&mut self, n: i32) {\n        self.value -= n;\n    }\n\n    pub fn multiply(&mut self, n: i32) {\n        self.value *= n;\n    }\n}\",\n    )\n    .unwrap();\n\n    repo.git_ai(&[\"checkpoint\", \"mock_ai\", \"calculator.rs\"])\n        .unwrap();\n    repo.stage_all_and_commit(\"AI adds subtract and multiply\")\n        .unwrap();\n\n    // Human refactors to add error handling\n    fs::write(\n        &file_path,\n        \"pub struct Calculator {\n    value: i32,\n}\n\nimpl Calculator {\n    pub fn new() -> Self {\n        Self { value: 0 }\n    }\n\n    pub fn add(&mut self, n: i32) -> Result<(), String> {\n        self.value = self.value.checked_add(n).ok_or(\\\"Overflow\\\")?;\n        Ok(())\n    }\n\n    pub fn subtract(&mut self, n: i32) {\n        self.value -= n;\n    }\n\n    pub fn multiply(&mut self, n: i32) {\n        self.value *= n;\n    }\n}\",\n    )\n    .unwrap();\n\n    repo.git_ai(&[\"checkpoint\"]).unwrap();\n    repo.stage_all_and_commit(\"Human adds overflow check to add\")\n        .unwrap();\n\n    // AI completes the refactoring for other methods\n    fs::write(\n        &file_path,\n        \"pub struct Calculator {\n    value: i32,\n}\n\nimpl Calculator {\n    pub fn new() -> Self {\n        Self { value: 0 }\n    }\n\n    pub fn add(&mut self, n: i32) -> Result<(), String> {\n        self.value = self.value.checked_add(n).ok_or(\\\"Overflow\\\")?;\n        Ok(())\n    }\n\n    pub fn subtract(&mut self, n: i32) -> Result<(), String> {\n        self.value = self.value.checked_sub(n).ok_or(\\\"Underflow\\\")?;\n        Ok(())\n    }\n\n    pub fn multiply(&mut self, n: i32) -> Result<(), String> {\n        self.value = self.value.checked_mul(n).ok_or(\\\"Overflow\\\")?;\n        Ok(())\n    }\n}\",\n    )\n    .unwrap();\n\n    repo.git_ai(&[\"checkpoint\", \"mock_ai\", \"calculator.rs\"])\n        .unwrap();\n    repo.stage_all_and_commit(\"AI adds error handling to other methods\")\n        .unwrap();\n\n    // Verify final attribution\n    let mut file = repo.filename(\"calculator.rs\");\n    file.assert_lines_and_blame(lines![\n        \"pub struct Calculator {\".human(),\n        \"    value: i32,\".human(),\n        \"}\".human(),\n        \"\".human(),\n        \"impl Calculator {\".human(),\n        \"    pub fn new() -> Self {\".human(),\n        \"        Self { value: 0 }\".human(),\n        \"    }\".human(),\n        \"    \".human(),\n        \"    pub fn add(&mut self, n: i32) -> Result<(), String> {\".human(),\n        \"        self.value = self.value.checked_add(n).ok_or(\\\"Overflow\\\")?;\".human(),\n        \"        Ok(())\".human(),\n        \"    }\".human(),\n        \"    \".human(),\n        \"    pub fn subtract(&mut self, n: i32) -> Result<(), String> {\".ai(),\n        \"        self.value = self.value.checked_sub(n).ok_or(\\\"Underflow\\\")?;\".ai(),\n        \"        Ok(())\".ai(),\n        \"    }\".ai(),\n        \"    \".ai(),\n        \"    pub fn multiply(&mut self, n: i32) -> Result<(), String> {\".ai(),\n        \"        self.value = self.value.checked_mul(n).ok_or(\\\"Overflow\\\")?;\".ai(),\n        \"        Ok(())\".ai(),\n        \"    }\".ai(),\n        \"}\".human(),\n    ]);\n}",
            "old_string": "    assert_eq!(\n        stats[\"ai_additions\"].as_u64().unwrap(),\n        2,\n        \"AI additions should be 2, not 4 (Bug #193)\"\n    );\n}"
          },
          "timestamp": "2025-11-22T16:04:19.022Z"
        },
        {
          "type": "user",
          "text": "<tool_use_error>File has not been read yet. Read it first before writing to it.</tool_use_error>",
          "timestamp": "2025-11-22T16:04:19.095Z"
        },
        {
          "type": "assistant",
          "text": "The file was already read at the start. Let me just append the new tests to the end:",
          "timestamp": "2025-11-22T16:04:22.742Z"
        },
        {
          "type": "tool_use",
          "name": "Write",
          "input": {
            "content": "#[macro_use]\nmod repos;\nuse repos::test_file::ExpectedLineExt;\nuse repos::test_repo::TestRepo;\nuse std::fs;\n\n#[test]\nfn test_realistic_refactoring_sequence() {\n    // Test a realistic code refactoring scenario with multiple human and AI edits\n    let repo = TestRepo::new();\n    let file_path = repo.path().join(\"calculator.rs\");\n\n    // Initial human-written code\n    fs::write(\n        &file_path,\n        \"pub struct Calculator {\n    value: i32,\n}\n\nimpl Calculator {\n    pub fn new() -> Self {\n        Self { value: 0 }\n    }\n\n    pub fn add(&mut self, n: i32) {\n        self.value += n;\n    }\n}\",\n    )\n    .unwrap();\n\n    repo.git_ai(&[\"checkpoint\"]).unwrap();\n    repo.stage_all_and_commit(\"Initial calculator implementation\")\n        .unwrap();\n\n    // AI adds subtract and multiply methods\n    fs::write(\n        &file_path,\n        \"pub struct Calculator {\n    value: i32,\n}\n\nimpl Calculator {\n    pub fn new() -> Self {\n        Self { value: 0 }\n    }\n\n    pub fn add(&mut self, n: i32) {\n        self.value += n;\n    }\n\n    pub fn subtract(&mut self, n: i32) {\n        self.value -= n;\n    }\n\n    pub fn multiply(&mut self, n: i32) {\n        self.value *= n;\n    }\n}\",\n    )\n    .unwrap();\n\n    repo.git_ai(&[\"checkpoint\", \"mock_ai\", \"calculator.rs\"])\n        .unwrap();\n    repo.stage_all_and_commit(\"AI adds subtract and multiply\")\n        .unwrap();\n\n    // Human refactors to add error handling\n    fs::write(\n        &file_path,\n        \"pub struct Calculator {\n    value: i32,\n}\n\nimpl Calculator {\n    pub fn new() -> Self {\n        Self { value: 0 }\n    }\n\n    pub fn add(&mut self, n: i32) -> Result<(), String> {\n        self.value = self.value.checked_add(n).ok_or(\\\"Overflow\\\")?;\n        Ok(())\n    }\n\n    pub fn subtract(&mut self, n: i32) {\n        self.value -= n;\n    }\n\n    pub fn multiply(&mut self, n: i32) {\n        self.value *= n;\n    }\n}\",\n    )\n    .unwrap();\n\n    repo.git_ai(&[\"checkpoint\"]).unwrap();\n    repo.stage_all_and_commit(\"Human adds overflow check to add\")\n        .unwrap();\n\n    // AI completes the refactoring for other methods\n    fs::write(\n        &file_path,\n        \"pub struct Calculator {\n    value: i32,\n}\n\nimpl Calculator {\n    pub fn new() -> Self {\n        Self { value: 0 }\n    }\n\n    pub fn add(&mut self, n: i32) -> Result<(), String> {\n        self.value = self.value.checked_add(n).ok_or(\\\"Overflow\\\")?;\n        Ok(())\n    }\n\n    pub fn subtract(&mut self, n: i32) -> Result<(), String> {\n        self.value = self.value.checked_sub(n).ok_or(\\\"Underflow\\\")?;\n        Ok(())\n    }\n\n    pub fn multiply(&mut self, n: i32) -> Result<(), String> {\n        self.value = self.value.checked_mul(n).ok_or(\\\"Overflow\\\")?;\n        Ok(())\n    }\n}\",\n    )\n    .unwrap();\n\n    repo.git_ai(&[\"checkpoint\", \"mock_ai\", \"calculator.rs\"])\n        .unwrap();\n    repo.stage_all_and_commit(\"AI adds error handling to other methods\")\n        .unwrap();\n\n    // Verify final attribution\n    let mut file = repo.filename(\"calculator.rs\");\n    file.assert_lines_and_blame(lines![\n        \"pub struct Calculator {\".human(),\n        \"    value: i32,\".human(),\n        \"}\".human(),\n        \"\".human(),\n        \"impl Calculator {\".human(),\n        \"    pub fn new() -> Self {\".human(),\n        \"        Self { value: 0 }\".human(),\n        \"    }\".human(),\n        \"    \".human(),\n        \"    pub fn add(&mut self, n: i32) -> Result<(), String> {\".human(),\n        \"        self.value = self.value.checked_add(n).ok_or(\\\"Overflow\\\")?;\".human(),\n        \"        Ok(())\".human(),\n        \"    }\".human(),\n        \"    \".human(),\n        \"    pub fn subtract(&mut self, n: i32) -> Result<(), String> {\".ai(),\n        \"        self.value = self.value.checked_sub(n).ok_or(\\\"Underflow\\\")?;\".ai(),\n        \"        Ok(())\".ai(),\n        \"    }\".ai(),\n        \"    \".ai(),\n        \"    pub fn multiply(&mut self, n: i32) -> Result<(), String> {\".ai(),\n        \"        self.value = self.value.checked_mul(n).ok_or(\\\"Overflow\\\")?;\".ai(),\n        \"        Ok(())\".ai(),\n        \"    }\".ai(),\n        \"}\".human(),\n    ]);\n}\n\n#[test]\nfn test_realistic_api_endpoint_expansion() {\n    // Test AI expanding an API with multiple endpoints, with human edits in between\n    let repo = TestRepo::new();\n    let file_path = repo.path().join(\"handlers.rs\");\n\n    // Human writes initial GET endpoint\n    fs::write(\n        &file_path,\n        \"use axum::{Json, extract::Path};\n\npub async fn get_user(Path(id): Path<u32>) -> Json<User> {\n    let user = fetch_user_from_db(id).await;\n    Json(user)\n}\",\n    )\n    .unwrap();\n\n    repo.git_ai(&[\"checkpoint\"]).unwrap();\n    repo.stage_all_and_commit(\"Add get_user endpoint\")\n        .unwrap();\n\n    // AI adds POST endpoint\n    fs::write(\n        &file_path,\n        \"use axum::{Json, extract::Path};\n\npub async fn get_user(Path(id): Path<u32>) -> Json<User> {\n    let user = fetch_user_from_db(id).await;\n    Json(user)\n}\n\npub async fn create_user(Json(payload): Json<CreateUser>) -> Json<User> {\n    let user = insert_user_to_db(payload).await;\n    Json(user)\n}\",\n    )\n    .unwrap();\n\n    repo.git_ai(&[\"checkpoint\", \"mock_ai\", \"handlers.rs\"])\n        .unwrap();\n    repo.stage_all_and_commit(\"AI adds create_user endpoint\")\n        .unwrap();\n\n    // Human adds validation to create_user\n    fs::write(\n        &file_path,\n        \"use axum::{Json, extract::Path};\n\npub async fn get_user(Path(id): Path<u32>) -> Json<User> {\n    let user = fetch_user_from_db(id).await;\n    Json(user)\n}\n\npub async fn create_user(Json(payload): Json<CreateUser>) -> Result<Json<User>, String> {\n    if payload.username.is_empty() {\n        return Err(\\\"Username cannot be empty\\\".to_string());\n    }\n    let user = insert_user_to_db(payload).await;\n    Ok(Json(user))\n}\",\n    )\n    .unwrap();\n\n    repo.git_ai(&[\"checkpoint\"]).unwrap();\n    repo.stage_all_and_commit(\"Human adds validation\")\n        .unwrap();\n\n    // AI adds UPDATE and DELETE endpoints\n    fs::write(\n        &file_path,\n        \"use axum::{Json, extract::Path};\n\npub async fn get_user(Path(id): Path<u32>) -> Json<User> {\n    let user = fetch_user_from_db(id).await;\n    Json(user)\n}\n\npub async fn create_user(Json(payload): Json<CreateUser>) -> Result<Json<User>, String> {\n    if payload.username.is_empty() {\n        return Err(\\\"Username cannot be empty\\\".to_string());\n    }\n    let user = insert_user_to_db(payload).await;\n    Ok(Json(user))\n}\n\npub async fn update_user(Path(id): Path<u32>, Json(payload): Json<UpdateUser>) -> Json<User> {\n    let user = update_user_in_db(id, payload).await;\n    Json(user)\n}\n\npub async fn delete_user(Path(id): Path<u32>) -> Json<()> {\n    delete_user_from_db(id).await;\n    Json(())\n}\",\n    )\n    .unwrap();\n\n    repo.git_ai(&[\"checkpoint\", \"mock_ai\", \"handlers.rs\"])\n        .unwrap();\n    repo.stage_all_and_commit(\"AI adds update and delete endpoints\")\n        .unwrap();\n\n    // Human refactors error handling across all endpoints\n    fs::write(\n        &file_path,\n        \"use axum::{Json, extract::Path, http::StatusCode};\n\npub async fn get_user(Path(id): Path<u32>) -> Result<Json<User>, StatusCode> {\n    let user = fetch_user_from_db(id).await?;\n    Ok(Json(user))\n}\n\npub async fn create_user(Json(payload): Json<CreateUser>) -> Result<Json<User>, StatusCode> {\n    if payload.username.is_empty() {\n        return Err(StatusCode::BAD_REQUEST);\n    }\n    let user = insert_user_to_db(payload).await?;\n    Ok(Json(user))\n}\n\npub async fn update_user(Path(id): Path<u32>, Json(payload): Json<UpdateUser>) -> Json<User> {\n    let user = update_user_in_db(id, payload).await;\n    Json(user)\n}\n\npub async fn delete_user(Path(id): Path<u32>) -> Json<()> {\n    delete_user_from_db(id).await;\n    Json(())\n}\",\n    )\n    .unwrap();\n\n    repo.git_ai(&[\"checkpoint\"]).unwrap();\n    repo.stage_all_and_commit(\"Human refactors error handling\")\n        .unwrap();\n\n    // Verify attribution aligns with git blame\n    let mut file = repo.filename(\"handlers.rs\");\n    file.assert_lines_and_blame(lines![\n        \"use axum::{Json, extract::Path, http::StatusCode};\".human(),\n        \"\".human(),\n        \"pub async fn get_user(Path(id): Path<u32>) -> Result<Json<User>, StatusCode> {\".human(),\n        \"    let user = fetch_user_from_db(id).await?;\".human(),\n        \"    Ok(Json(user))\".human(),\n        \"}\".human(),\n        \"\".human(),\n        \"pub async fn create_user(Json(payload): Json<CreateUser>) -> Result<Json<User>, StatusCode> {\".human(),\n        \"    if payload.username.is_empty() {\".human(),\n        \"        return Err(StatusCode::BAD_REQUEST);\".human(),\n        \"    }\".human(),\n        \"    let user = insert_user_to_db(payload).await?;\".human(),\n        \"    Ok(Json(user))\".human(),\n        \"}\".human(),\n        \"\".ai(),\n        \"pub async fn update_user(Path(id): Path<u32>, Json(payload): Json<UpdateUser>) -> Json<User> {\".ai(),\n        \"    let user = update_user_in_db(id, payload).await;\".ai(),\n        \"    Json(user)\".ai(),\n        \"}\".ai(),\n        \"\".ai(),\n        \"pub async fn delete_user(Path(id): Path<u32>) -> Json<()> {\".ai(),\n        \"    delete_user_from_db(id).await;\".ai(),\n        \"    Json(())\".ai(),\n        \"}\".ai(),\n    ]);\n}\n\n#[test]\nfn test_realistic_test_file_evolution() {\n    // Test evolution of a test file with AI adding tests and human refactoring\n    let repo = TestRepo::new();\n    let file_path = repo.path().join(\"tests.rs\");\n\n    // Human writes initial test\n    fs::write(\n        &file_path,\n        \"#[test]\nfn test_addition() {\n    assert_eq!(2 + 2, 4);\n}\",\n    )\n    .unwrap();\n\n    repo.git_ai(&[\"checkpoint\"]).unwrap();\n    repo.stage_all_and_commit(\"Initial test\").unwrap();\n\n    // AI adds more test cases\n    fs::write(\n        &file_path,\n        \"#[test]\nfn test_addition() {\n    assert_eq!(2 + 2, 4);\n}\n\n#[test]\nfn test_subtraction() {\n    assert_eq!(5 - 3, 2);\n}\n\n#[test]\nfn test_multiplication() {\n    assert_eq!(3 * 4, 12);\n}\",\n    )\n    .unwrap();\n\n    repo.git_ai(&[\"checkpoint\", \"mock_ai\", \"tests.rs\"])\n        .unwrap();\n    repo.stage_all_and_commit(\"AI adds more tests\").unwrap();\n\n    // Human refactors to use test module\n    fs::write(\n        &file_path,\n        \"mod arithmetic_tests {\n    #[test]\n    fn test_addition() {\n        assert_eq!(2 + 2, 4);\n    }\n\n    #[test]\n    fn test_subtraction() {\n        assert_eq!(5 - 3, 2);\n    }\n\n    #[test]\n    fn test_multiplication() {\n        assert_eq!(3 * 4, 12);\n    }\n}\",\n    )\n    .unwrap();\n\n    repo.git_ai(&[\"checkpoint\"]).unwrap();\n    repo.stage_all_and_commit(\"Human adds module wrapper\")\n        .unwrap();\n\n    // AI adds division test\n    fs::write(\n        &file_path,\n        \"mod arithmetic_tests {\n    #[test]\n    fn test_addition() {\n        assert_eq!(2 + 2, 4);\n    }\n\n    #[test]\n    fn test_subtraction() {\n        assert_eq!(5 - 3, 2);\n    }\n\n    #[test]\n    fn test_multiplication() {\n        assert_eq!(3 * 4, 12);\n    }\n\n    #[test]\n    fn test_division() {\n        assert_eq!(12 / 3, 4);\n    }\n}\",\n    )\n    .unwrap();\n\n    repo.git_ai(&[\"checkpoint\", \"mock_ai\", \"tests.rs\"])\n        .unwrap();\n    repo.stage_all_and_commit(\"AI adds division test\").unwrap();\n\n    // Human adds edge case test\n    fs::write(\n        &file_path,\n        \"mod arithmetic_tests {\n    #[test]\n    fn test_addition() {\n        assert_eq!(2 + 2, 4);\n    }\n\n    #[test]\n    fn test_subtraction() {\n        assert_eq!(5 - 3, 2);\n    }\n\n    #[test]\n    fn test_multiplication() {\n        assert_eq!(3 * 4, 12);\n    }\n\n    #[test]\n    fn test_division() {\n        assert_eq!(12 / 3, 4);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_division_by_zero() {\n        let _ = 1 / 0;\n    }\n}\",\n    )\n    .unwrap();\n\n    repo.git_ai(&[\"checkpoint\"]).unwrap();\n    repo.stage_all_and_commit(\"Human adds edge case test\")\n        .unwrap();\n\n    // Verify git alignment\n    let mut file = repo.filename(\"tests.rs\");\n    file.assert_lines_and_blame(lines![\n        \"mod arithmetic_tests {\".human(),\n        \"    #[test]\".human(),\n        \"    fn test_addition() {\".human(),\n        \"        assert_eq!(2 + 2, 4);\".human(),\n        \"    }\".human(),\n        \"\".human(),\n        \"    #[test]\".ai(),\n        \"    fn test_subtraction() {\".ai(),\n        \"        assert_eq!(5 - 3, 2);\".ai(),\n        \"    }\".ai(),\n        \"\".ai(),\n        \"    #[test]\".ai(),\n        \"    fn test_multiplication() {\".ai(),\n        \"        assert_eq!(3 * 4, 12);\".ai(),\n        \"    }\".ai(),\n        \"\".ai(),\n        \"    #[test]\".ai(),\n        \"    fn test_division() {\".ai(),\n        \"        assert_eq!(12 / 3, 4);\".ai(),\n        \"    }\".ai(),\n        \"\".human(),\n        \"    #[test]\".human(),\n        \"    #[should_panic]\".human(),\n        \"    fn test_division_by_zero() {\".human(),\n        \"        let _ = 1 / 0;\".human(),\n        \"    }\".human(),\n        \"}\".human(),\n    ]);\n}\n\n#[test]\nfn test_realistic_config_file_with_comments() {\n    // Test AI and human editing a config file with comments\n    let repo = TestRepo::new();\n    let file_path = repo.path().join(\"config.toml\");\n\n    // Human creates initial config\n    fs::write(\n        &file_path,\n        \"[server]\nhost = \\\"localhost\\\"\nport = 8080\",\n    )\n    .unwrap();\n\n    repo.git_ai(&[\"checkpoint\"]).unwrap();\n    repo.stage_all_and_commit(\"Initial config\").unwrap();\n\n    // AI adds database config\n    fs::write(\n        &file_path,\n        \"[server]\nhost = \\\"localhost\\\"\nport = 8080\n\n[database]\nurl = \\\"postgresql://localhost/mydb\\\"\nmax_connections = 10\",\n    )\n    .unwrap();\n\n    repo.git_ai(&[\"checkpoint\", \"mock_ai\", \"config.toml\"])\n        .unwrap();\n    repo.stage_all_and_commit(\"AI adds database config\")\n        .unwrap();\n\n    // Human adds comments and changes port\n    fs::write(\n        &file_path,\n        \"# Server configuration\n[server]\nhost = \\\"localhost\\\"\n# Changed to use port 3000\nport = 3000\n\n[database]\nurl = \\\"postgresql://localhost/mydb\\\"\nmax_connections = 10\",\n    )\n    .unwrap();\n\n    repo.git_ai(&[\"checkpoint\"]).unwrap();\n    repo.stage_all_and_commit(\"Human adds comments and changes port\")\n        .unwrap();\n\n    // AI adds logging config\n    fs::write(\n        &file_path,\n        \"# Server configuration\n[server]\nhost = \\\"localhost\\\"\n# Changed to use port 3000\nport = 3000\n\n[database]\nurl = \\\"postgresql://localhost/mydb\\\"\nmax_connections = 10\n\n[logging]\nlevel = \\\"info\\\"\nformat = \\\"json\\\"\",\n    )\n    .unwrap();\n\n    repo.git_ai(&[\"checkpoint\", \"mock_ai\", \"config.toml\"])\n        .unwrap();\n    repo.stage_all_and_commit(\"AI adds logging config\")\n        .unwrap();\n\n    // Verify alignment with git\n    let mut file = repo.filename(\"config.toml\");\n    file.assert_lines_and_blame(lines![\n        \"# Server configuration\".human(),\n        \"[server]\".human(),\n        \"host = \\\"localhost\\\"\".human(),\n        \"# Changed to use port 3000\".human(),\n        \"port = 3000\".human(),\n        \"\".human(),\n        \"[database]\".ai(),\n        \"url = \\\"postgresql://localhost/mydb\\\"\".ai(),\n        \"max_connections = 10\".ai(),\n        \"\".ai(),\n        \"[logging]\".ai(),\n        \"level = \\\"info\\\"\".ai(),\n        \"format = \\\"json\\\"\".ai(),\n    ]);\n}\n\n#[test]\nfn test_realistic_jsx_component_development() {\n    // Test AI and human building a React component together\n    let repo = TestRepo::new();\n    let file_path = repo.path().join(\"Button.jsx\");\n\n    // Human creates basic component\n    fs::write(\n        &file_path,\n        \"export function Button({ children }) {\n  return <button>{children}</button>;\n}\",\n    )\n    .unwrap();\n\n    repo.git_ai(&[\"checkpoint\"]).unwrap();\n    repo.stage_all_and_commit(\"Initial Button component\")\n        .unwrap();\n\n    // AI adds onClick and styling props\n    fs::write(\n        &file_path,\n        \"export function Button({ children, onClick, className }) {\n  return (\n    <button onClick={onClick} className={className}>\n      {children}\n    </button>\n  );\n}\",\n    )\n    .unwrap();\n\n    repo.git_ai(&[\"checkpoint\", \"mock_ai\", \"Button.jsx\"])\n        .unwrap();\n    repo.stage_all_and_commit(\"AI adds onClick and className props\")\n        .unwrap();\n\n    // Human adds variant prop with styles\n    fs::write(\n        &file_path,\n        \"export function Button({ children, onClick, className, variant = 'primary' }) {\n  const baseStyles = 'px-4 py-2 rounded';\n  const variantStyles = variant === 'primary' ? 'bg-blue-500 text-white' : 'bg-gray-200';\n\n  return (\n    <button onClick={onClick} className={`${baseStyles} ${variantStyles} ${className}`}>\n      {children}\n    </button>\n  );\n}\",\n    )\n    .unwrap();\n\n    repo.git_ai(&[\"checkpoint\"]).unwrap();\n    repo.stage_all_and_commit(\"Human adds variant styling\")\n        .unwrap();\n\n    // AI adds disabled state\n    fs::write(\n        &file_path,\n        \"export function Button({ children, onClick, className, variant = 'primary', disabled = false }) {\n  const baseStyles = 'px-4 py-2 rounded';\n  const variantStyles = variant === 'primary' ? 'bg-blue-500 text-white' : 'bg-gray-200';\n  const disabledStyles = disabled ? 'opacity-50 cursor-not-allowed' : '';\n\n  return (\n    <button\n      onClick={disabled ? undefined : onClick}\n      className={`${baseStyles} ${variantStyles} ${disabledStyles} ${className}`}\n      disabled={disabled}\n    >\n      {children}\n    </button>\n  );\n}\",\n    )\n    .unwrap();\n\n    repo.git_ai(&[\"checkpoint\", \"mock_ai\", \"Button.jsx\"])\n        .unwrap();\n    repo.stage_all_and_commit(\"AI adds disabled state\").unwrap();\n\n    // Verify git blame alignment\n    let mut file = repo.filename(\"Button.jsx\");\n    file.assert_lines_and_blame(lines![\n        \"export function Button({ children, onClick, className, variant = 'primary', disabled = false }) {\".ai(),\n        \"  const baseStyles = 'px-4 py-2 rounded';\".human(),\n        \"  const variantStyles = variant === 'primary' ? 'bg-blue-500 text-white' : 'bg-gray-200';\".human(),\n        \"  const disabledStyles = disabled ? 'opacity-50 cursor-not-allowed' : '';\".ai(),\n        \"  \".ai(),\n        \"  return (\".ai(),\n        \"    <button \".ai(),\n        \"      onClick={disabled ? undefined : onClick} \".ai(),\n        \"      className={`${baseStyles} ${variantStyles} ${disabledStyles} ${className}`}\".ai(),\n        \"      disabled={disabled}\".ai(),\n        \"    >\".ai(),\n        \"      {children}\".ai(),\n        \"    </button>\".ai(),\n        \"  );\".ai(),\n        \"}\".ai(),\n    ]);\n}\n\n#[test]\nfn test_realistic_class_with_multiple_methods() {\n    // Test complex class evolution with multiple method additions and modifications\n    let repo = TestRepo::new();\n    let file_path = repo.path().join(\"UserManager.ts\");\n\n    // Human creates initial class with one method\n    fs::write(\n        &file_path,\n        \"export class UserManager {\n  private users: Map<string, User> = new Map();\n\n  constructor() {}\n\n  addUser(user: User): void {\n    this.users.set(user.id, user);\n  }\n}\",\n    )\n    .unwrap();\n\n    repo.git_ai(&[\"checkpoint\"]).unwrap();\n    repo.stage_all_and_commit(\"Initial UserManager class\")\n        .unwrap();\n\n    // AI adds getUser and removeUser\n    fs::write(\n        &file_path,\n        \"export class UserManager {\n  private users: Map<string, User> = new Map();\n\n  constructor() {}\n\n  addUser(user: User): void {\n    this.users.set(user.id, user);\n  }\n\n  getUser(id: string): User | undefined {\n    return this.users.get(id);\n  }\n\n  removeUser(id: string): boolean {\n    return this.users.delete(id);\n  }\n}\",\n    )\n    .unwrap();\n\n    repo.git_ai(&[\"checkpoint\", \"mock_ai\", \"UserManager.ts\"])\n        .unwrap();\n    repo.stage_all_and_commit(\"AI adds getUser and removeUser\")\n        .unwrap();\n\n    // Human refactors addUser to validate\n    fs::write(\n        &file_path,\n        \"export class UserManager {\n  private users: Map<string, User> = new Map();\n\n  constructor() {}\n\n  addUser(user: User): void {\n    if (!user.id || !user.email) {\n      throw new Error('Invalid user');\n    }\n    this.users.set(user.id, user);\n  }\n\n  getUser(id: string): User | undefined {\n    return this.users.get(id);\n  }\n\n  removeUser(id: string): boolean {\n    return this.users.delete(id);\n  }\n}\",\n    )\n    .unwrap();\n\n    repo.git_ai(&[\"checkpoint\"]).unwrap();\n    repo.stage_all_and_commit(\"Human adds validation to addUser\")\n        .unwrap();\n\n    // AI adds updateUser method\n    fs::write(\n        &file_path,\n        \"export class UserManager {\n  private users: Map<string, User> = new Map();\n\n  constructor() {}\n\n  addUser(user: User): void {\n    if (!user.id || !user.email) {\n      throw new Error('Invalid user');\n    }\n    this.users.set(user.id, user);\n  }\n\n  getUser(id: string): User | undefined {\n    return this.users.get(id);\n  }\n\n  updateUser(id: string, updates: Partial<User>): User | undefined {\n    const user = this.users.get(id);\n    if (!user) return undefined;\n    const updatedUser = { ...user, ...updates };\n    this.users.set(id, updatedUser);\n    return updatedUser;\n  }\n\n  removeUser(id: string): boolean {\n    return this.users.delete(id);\n  }\n}\",\n    )\n    .unwrap();\n\n    repo.git_ai(&[\"checkpoint\", \"mock_ai\", \"UserManager.ts\"])\n        .unwrap();\n    repo.stage_all_and_commit(\"AI adds updateUser method\")\n        .unwrap();\n\n    // Human adds getAllUsers and count\n    fs::write(\n        &file_path,\n        \"export class UserManager {\n  private users: Map<string, User> = new Map();\n\n  constructor() {}\n\n  addUser(user: User): void {\n    if (!user.id || !user.email) {\n      throw new Error('Invalid user');\n    }\n    this.users.set(user.id, user);\n  }\n\n  getUser(id: string): User | undefined {\n    return this.users.get(id);\n  }\n\n  getAllUsers(): User[] {\n    return Array.from(this.users.values());\n  }\n\n  getUserCount(): number {\n    return this.users.size;\n  }\n\n  updateUser(id: string, updates: Partial<User>): User | undefined {\n    const user = this.users.get(id);\n    if (!user) return undefined;\n    const updatedUser = { ...user, ...updates };\n    this.users.set(id, updatedUser);\n    return updatedUser;\n  }\n\n  removeUser(id: string): boolean {\n    return this.users.delete(id);\n  }\n}\",\n    )\n    .unwrap();\n\n    repo.git_ai(&[\"checkpoint\"]).unwrap();\n    repo.stage_all_and_commit(\"Human adds getAllUsers and getUserCount\")\n        .unwrap();\n\n    // Verify git blame alignment\n    let mut file = repo.filename(\"UserManager.ts\");\n    file.assert_lines_and_blame(lines![\n        \"export class UserManager {\".human(),\n        \"  private users: Map<string, User> = new Map();\".human(),\n        \"\".human(),\n        \"  constructor() {}\".human(),\n        \"\".human(),\n        \"  addUser(user: User): void {\".human(),\n        \"    if (!user.id || !user.email) {\".human(),\n        \"      throw new Error('Invalid user');\".human(),\n        \"    }\".human(),\n        \"    this.users.set(user.id, user);\".human(),\n        \"  }\".human(),\n        \"\".human(),\n        \"  getUser(id: string): User | undefined {\".ai(),\n        \"    return this.users.get(id);\".ai(),\n        \"  }\".ai(),\n        \"\".human(),\n        \"  getAllUsers(): User[] {\".human(),\n        \"    return Array.from(this.users.values());\".human(),\n        \"  }\".human(),\n        \"\".human(),\n        \"  getUserCount(): number {\".human(),\n        \"    return this.users.size;\".human(),\n        \"  }\".human(),\n        \"\".ai(),\n        \"  updateUser(id: string, updates: Partial<User>): User | undefined {\".ai(),\n        \"    const user = this.users.get(id);\".ai(),\n        \"    if (!user) return undefined;\".ai(),\n        \"    const updatedUser = { ...user, ...updates };\".ai(),\n        \"    this.users.set(id, updatedUser);\".ai(),\n        \"    return updatedUser;\".ai(),\n        \"  }\".ai(),\n        \"\".ai(),\n        \"  removeUser(id: string): boolean {\".ai(),\n        \"    return this.users.delete(id);\".ai(),\n        \"  }\".ai(),\n        \"}\".human(),\n    ]);\n}\n\n#[test]\nfn test_realistic_middleware_chain_development() {\n    // Test building middleware with AI and human working together\n    let repo = TestRepo::new();\n    let file_path = repo.path().join(\"middleware.ts\");\n\n    // Human creates basic logging middleware\n    fs::write(\n        &file_path,\n        \"export function loggerMiddleware(req, res, next) {\n  console.log(`${req.method} ${req.path}`);\n  next();\n}\",\n    )\n    .unwrap();\n\n    repo.git_ai(&[\"checkpoint\"]).unwrap();\n    repo.stage_all_and_commit(\"Initial logger middleware\")\n        .unwrap();\n\n    // AI adds auth middleware\n    fs::write(\n        &file_path,\n        \"export function loggerMiddleware(req, res, next) {\n  console.log(`${req.method} ${req.path}`);\n  next();\n}\n\nexport function authMiddleware(req, res, next) {\n  const token = req.headers['authorization'];\n  if (!token) {\n    return res.status(401).json({ error: 'Unauthorized' });\n  }\n  next();\n}\",\n    )\n    .unwrap();\n\n    repo.git_ai(&[\"checkpoint\", \"mock_ai\", \"middleware.ts\"])\n        .unwrap();\n    repo.stage_all_and_commit(\"AI adds auth middleware\")\n        .unwrap();\n\n    // Human improves logging with timestamps\n    fs::write(\n        &file_path,\n        \"export function loggerMiddleware(req, res, next) {\n  const timestamp = new Date().toISOString();\n  console.log(`[${timestamp}] ${req.method} ${req.path}`);\n  next();\n}\n\nexport function authMiddleware(req, res, next) {\n  const token = req.headers['authorization'];\n  if (!token) {\n    return res.status(401).json({ error: 'Unauthorized' });\n  }\n  next();\n}\",\n    )\n    .unwrap();\n\n    repo.git_ai(&[\"checkpoint\"]).unwrap();\n    repo.stage_all_and_commit(\"Human adds timestamps to logger\")\n        .unwrap();\n\n    // AI adds rate limiting middleware\n    fs::write(\n        &file_path,\n        \"export function loggerMiddleware(req, res, next) {\n  const timestamp = new Date().toISOString();\n  console.log(`[${timestamp}] ${req.method} ${req.path}`);\n  next();\n}\n\nexport function authMiddleware(req, res, next) {\n  const token = req.headers['authorization'];\n  if (!token) {\n    return res.status(401).json({ error: 'Unauthorized' });\n  }\n  next();\n}\n\nconst rateLimitStore = new Map();\n\nexport function rateLimitMiddleware(limit = 100) {\n  return (req, res, next) => {\n    const ip = req.ip;\n    const count = rateLimitStore.get(ip) || 0;\n    if (count >= limit) {\n      return res.status(429).json({ error: 'Rate limit exceeded' });\n    }\n    rateLimitStore.set(ip, count + 1);\n    next();\n  };\n}\",\n    )\n    .unwrap();\n\n    repo.git_ai(&[\"checkpoint\", \"mock_ai\", \"middleware.ts\"])\n        .unwrap();\n    repo.stage_all_and_commit(\"AI adds rate limiting\")\n        .unwrap();\n\n    // Human adds error handling middleware\n    fs::write(\n        &file_path,\n        \"export function loggerMiddleware(req, res, next) {\n  const timestamp = new Date().toISOString();\n  console.log(`[${timestamp}] ${req.method} ${req.path}`);\n  next();\n}\n\nexport function authMiddleware(req, res, next) {\n  const token = req.headers['authorization'];\n  if (!token) {\n    return res.status(401).json({ error: 'Unauthorized' });\n  }\n  next();\n}\n\nconst rateLimitStore = new Map();\n\nexport function rateLimitMiddleware(limit = 100) {\n  return (req, res, next) => {\n    const ip = req.ip;\n    const count = rateLimitStore.get(ip) || 0;\n    if (count >= limit) {\n      return res.status(429).json({ error: 'Rate limit exceeded' });\n    }\n    rateLimitStore.set(ip, count + 1);\n    next();\n  };\n}\n\nexport function errorHandlerMiddleware(err, req, res, next) {\n  console.error('Error:', err);\n  res.status(500).json({ error: 'Internal server error' });\n}\",\n    )\n    .unwrap();\n\n    repo.git_ai(&[\"checkpoint\"]).unwrap();\n    repo.stage_all_and_commit(\"Human adds error handler\")\n        .unwrap();\n\n    // Verify git alignment\n    let mut file = repo.filename(\"middleware.ts\");\n    file.assert_lines_and_blame(lines![\n        \"export function loggerMiddleware(req, res, next) {\".human(),\n        \"  const timestamp = new Date().toISOString();\".human(),\n        \"  console.log(`[${timestamp}] ${req.method} ${req.path}`);\".human(),\n        \"  next();\".human(),\n        \"}\".human(),\n        \"\".human(),\n        \"export function authMiddleware(req, res, next) {\".ai(),\n        \"  const token = req.headers['authorization'];\".ai(),\n        \"  if (!token) {\".ai(),\n        \"    return res.status(401).json({ error: 'Unauthorized' });\".ai(),\n        \"  }\".ai(),\n        \"  next();\".ai(),\n        \"}\".ai(),\n        \"\".ai(),\n        \"const rateLimitStore = new Map();\".ai(),\n        \"\".ai(),\n        \"export function rateLimitMiddleware(limit = 100) {\".ai(),\n        \"  return (req, res, next) => {\".ai(),\n        \"    const ip = req.ip;\".ai(),\n        \"    const count = rateLimitStore.get(ip) || 0;\".ai(),\n        \"    if (count >= limit) {\".ai(),\n        \"      return res.status(429).json({ error: 'Rate limit exceeded' });\".ai(),\n        \"    }\".ai(),\n        \"    rateLimitStore.set(ip, count + 1);\".ai(),\n        \"    next();\".ai(),\n        \"  };\".ai(),\n        \"}\".ai(),\n        \"\".human(),\n        \"export function errorHandlerMiddleware(err, req, res, next) {\".human(),\n        \"  console.error('Error:', err);\".human(),\n        \"  res.status(500).json({ error: 'Internal server error' });\".human(),\n        \"}\".human(),\n    ]);\n}\n\n#[test]\nfn test_realistic_sql_migration_sequence() {\n    // Test AI and human collaborating on database migrations\n    let repo = TestRepo::new();\n    let file_path = repo.path().join(\"001_initial.sql\");\n\n    // Human creates initial users table\n    fs::write(\n        &file_path,\n        \"-- Initial migration\nCREATE TABLE users (\n  id SERIAL PRIMARY KEY,\n  email VARCHAR(255) NOT NULL\n);\",\n    )\n    .unwrap();\n\n    repo.git_ai(&[\"checkpoint\"]).unwrap();\n    repo.stage_all_and_commit(\"Initial migration\").unwrap();\n\n    // AI adds indexes and constraints\n    fs::write(\n        &file_path,\n        \"-- Initial migration\nCREATE TABLE users (\n  id SERIAL PRIMARY KEY,\n  email VARCHAR(255) NOT NULL,\n  UNIQUE(email)\n);\n\nCREATE INDEX idx_users_email ON users(email);\",\n    )\n    .unwrap();\n\n    repo.git_ai(&[\"checkpoint\", \"mock_ai\", \"001_initial.sql\"])\n        .unwrap();\n    repo.stage_all_and_commit(\"AI adds indexes and constraints\")\n        .unwrap();\n\n    // Human adds created_at column\n    fs::write(\n        &file_path,\n        \"-- Initial migration\nCREATE TABLE users (\n  id SERIAL PRIMARY KEY,\n  email VARCHAR(255) NOT NULL,\n  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n  UNIQUE(email)\n);\n\nCREATE INDEX idx_users_email ON users(email);\",\n    )\n    .unwrap();\n\n    repo.git_ai(&[\"checkpoint\"]).unwrap();\n    repo.stage_all_and_commit(\"Human adds created_at\")\n        .unwrap();\n\n    // AI adds posts table with foreign key\n    fs::write(\n        &file_path,\n        \"-- Initial migration\nCREATE TABLE users (\n  id SERIAL PRIMARY KEY,\n  email VARCHAR(255) NOT NULL,\n  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n  UNIQUE(email)\n);\n\nCREATE INDEX idx_users_email ON users(email);\n\nCREATE TABLE posts (\n  id SERIAL PRIMARY KEY,\n  user_id INTEGER NOT NULL,\n  title VARCHAR(255) NOT NULL,\n  content TEXT,\n  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE\n);\n\nCREATE INDEX idx_posts_user_id ON posts(user_id);\",\n    )\n    .unwrap();\n\n    repo.git_ai(&[\"checkpoint\", \"mock_ai\", \"001_initial.sql\"])\n        .unwrap();\n    repo.stage_all_and_commit(\"AI adds posts table\")\n        .unwrap();\n\n    // Verify alignment\n    let mut file = repo.filename(\"001_initial.sql\");\n    file.assert_lines_and_blame(lines![\n        \"-- Initial migration\".human(),\n        \"CREATE TABLE users (\".human(),\n        \"  id SERIAL PRIMARY KEY,\".human(),\n        \"  email VARCHAR(255) NOT NULL,\".human(),\n        \"  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\".human(),\n        \"  UNIQUE(email)\".ai(),\n        \");\".ai(),\n        \"\".ai(),\n        \"CREATE INDEX idx_users_email ON users(email);\".ai(),\n        \"\".ai(),\n        \"CREATE TABLE posts (\".ai(),\n        \"  id SERIAL PRIMARY KEY,\".ai(),\n        \"  user_id INTEGER NOT NULL,\".ai(),\n        \"  title VARCHAR(255) NOT NULL,\".ai(),\n        \"  content TEXT,\".ai(),\n        \"  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\".ai(),\n        \"  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE\".ai(),\n        \");\".ai(),\n        \"\".ai(),\n        \"CREATE INDEX idx_posts_user_id ON posts(user_id);\".ai(),\n    ]);\n}\n",
            "file_path": "/Users/svarlamov/projects/git-ai/tests/realistic_complex_edits.rs"
          },
          "timestamp": "2025-11-22T16:05:58.556Z"
        },
        {
          "type": "user",
          "text": "File created successfully at: /Users/svarlamov/projects/git-ai/tests/realistic_complex_edits.rs",
          "timestamp": "2025-11-22T16:14:14.272Z"
        }
      ],
      "total_additions": 1727,
      "total_deletions": 41,
      "accepted_lines": 1686,
      "overriden_lines": 0
    }
  }
}
